diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet.h b/drivers/net/ethernet/xilinx/xilinx_axienet.h
index 857e54643355..21e6ec2bd4ea 100755
--- a/drivers/net/ethernet/xilinx/xilinx_axienet.h
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet.h
@@ -407,29 +407,18 @@
 #define XXVS_AN_STATUS_OFFSET		0x0000458
 #define XXVS_AN_LP_STATUS_OFFSET	0x000045C
 #define XXVS_LT_STATUS_OFFSET		0x000046C
-#define XXVS_RX_STATUS_REG1		0x00000404
-#define XXVS_TC_OFFSET			0x0000000C
 
 /* Switchable 1/10/25G MAC Register Mask Definitions */
 #define XXVS_RX_SERDES_RESET		BIT(28)
 #define XXVS_AN_ENABLE_MASK		BIT(0)
-#define XXVS_AN_BYPASS			BIT(1)
 #define XXVS_AN_1G_ABILITY_MASK		BIT(0)
 #define XXVS_AN_10G_ABILITY_MASK	BIT(1)
-#define XXVS_AN_25G_ABILITY_MASK	BIT(10)
 #define XXVS_LT_ENABLE_MASK		BIT(0)
 #define XXVS_LT_TRAINED_MASK		BIT(0)
 #define XXVS_AN_COMPLETE_MASK		BIT(2)
 #define XXVS_LT_DETECT_MASK		BIT(0)
 #define XXVS_SPEED_1G			BIT(0)
 #define	XXVS_SPEED_10G			BIT(1)
-#define XXVS_SPEED_25G			~(BIT(0) | BIT(1))
-#define XXVS_RX_STATUS_MASK		BIT(0)
-#define XXVS_RX_RESET			BIT(30)
-#define XXVS_TX_RESET			BIT(31)
-#define XXVS_CTRL_CORE_SPEED_SEL_CLEAR		~(BIT(6) | BIT(7))
-#define XXVS_CTRL_CORE_SPEED_SEL_1G		BIT(6)
-#define XXVS_CTRL_CORE_SPEED_SEL_10G	BIT(7)
 
 /* XXV MAC Register Mask Definitions */
 #define XXV_GT_RESET_MASK	BIT(0)
@@ -559,9 +548,6 @@
 #define XXVS_LT_COEF_M1			0x1
 #define XXVS_LT_COEF_M1_SHIFT		10
 
-/* Switching 1/10/25G MAC "xlnx,runtime-switch" DT property value */
-#define XXVS_RT_SWITCH_1G_10G_25G		"1G / 10G / 25G"
-
 /* Default number of Tx descriptors */
 #define TX_BD_NUM_DEFAULT               128
 
@@ -653,7 +639,6 @@
 
 #define MRMAC_GT_LANE_OFFSET		BIT(16)
 #define MRMAC_MAX_GT_LANES		4
-
 #define MRMAC_GT_100G_RST_VALUE		0xF02
 #define	MRMAC_GT_100G_LINE_RATE		0x2
 
@@ -682,62 +667,6 @@
 #define MRMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG1_VAL  0x0000004F
 #define MRMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG2      0x000000A0
 #define MRMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG2_VAL  0x00084210
-/* DCMAC Register Definitions */
-/* Global registers */
-#define DCMAC_G_MODE_OFFSET		0x00000004
-#define DCMAC_G_CTRL_RX_OFFSET		0x000000F0
-#define DCMAC_G_CTRL_TX_OFFSET		0x000000F8
-/* Port registers */
-#define DCMAC_P_CTRL_RX_OFFSET		0x000010F0
-#define DCMAC_P_CTRL_TX_OFFSET		0x000010F8
-#define DCMAC_STS_RX_PHY_OFFSET		0x00001C00
-/* Port channel registers */
-#define DCMAC_CH_CFG_TX_OFFSET		0x00001000
-#define DCMAC_CH_CFG_RX_OFFSET		0x00001004
-#define DCMAC_CH_CTRL_RX_OFFSET		0x00001030
-#define DCMAC_CH_CTRL_TX_OFFSET		0x00001038
-#define DCMAC_CH_MODE_TX_OFFSET		0x00001040
-#define DCMAC_CH_MODE_RX_OFFSET		0x00001044
-/* Status Registers */
-#define DCMAC_TX_STS_OFFSET		0X00001100
-#define DCMAC_RX_STS_OFFSET		0X00001140
-
-/* Register bit masks */
-#define DCMAC_TX_ACTV_PRT_ALL_MASK	(BIT(16) | BIT(18))
-#define DCMAC_RX_ACTV_PRT_ALL_MASK	(BIT(20) | BIT(22))
-#define DCMAC_RX_ERR_IND_STD_MASK	BIT(24)	/* FEC error indication mode as IEEE Standard */
-#define DCMAC_TX_FEC_UNIQUE_FLIP_MASK	BIT(25)
-#define DCMAC_RX_FEC_UNIQUE_FLIP_MASK	BIT(26)
-#define DCMAC_CH_RX_FCS_MASK		BIT(1)
-#define DCMAC_CH_RX_PREAMBLE_MASK	BIT(5)
-#define DCMAC_RX_IGNR_INRANGE_MASK	BIT(6)
-#define DCMAC_RX_MAX_PKT_LEN_MASK	(BIT(23) | BIT(24) | BIT(26) | BIT(29))
-#define DCMAC_CH_TX_FCS_MASK		BIT(0)
-#define DCMAC_CH_TX_IPG_MASK		(BIT(10) | BIT(11))
-#define DCMAC_P_SPEED_100G_MASK		~(BIT(0) | BIT(1))
-#define DCMAC_P_SPEED_200G_MASK	BIT(1)
-#define DCMAC_P_SPEED_400G_MASK	BIT(2)
-#define DCMAC_CH_TXMD_PM_TICK_INTERNAL_MASK	BIT(4)
-#define DCMAC_CH_RXMD_PM_TICK_INTERNAL_MASK	BIT(11)
-#define DCMAC_CH_MD_FEC_KR4		(BIT(16) | BIT(18))
-#define DCMAC_CH_MD_FEC_200G		BIT(19)
-#define DCMAC_CH_MD_FEC_400G		BIT(20)
-#define DCMAC_P_CTRL_CLR_SERDES		BIT(1)
-#define DCMAC_G_CTRL_RESET_ALL		GENMASK(2, 0)
-#define DCMAC_P_CTRL_CLEAR_ALL		(BIT(0) | BIT(1))
-#define DCMAC_CH_CTRL_CLEAR_STATE	BIT(0)
-#define DCMAC_RXPHY_RX_STS_MASK		BIT(0)
-#define DCMAC_RXPHY_RX_ALIGN_MASK	BIT(2)
-#define DCMAC_RELEASE_RESET		0x0
-#define DCMAC_GT_RESET_DONE_MASK	GENMASK(3, 0)
-
-/* DCMAC GT wrapper bitmasks */
-#define DCMAC_GT_RESET_ALL	BIT(0)
-#define DCMAC_GT_TX_PRECURSOR	(BIT(12) | BIT(13))	/* gt_txprecursor */
-#define DCMAC_GT_TX_POSTCURSOR	(BIT(18) | BIT(21))	/* gt_txpostcursor */
-#define DCMAC_GT_MAINCURSOR	(BIT(24) | BIT(25) | BIT(27) | BIT(30))	/* gt maincursor */
-
-#define DCMAC_GT_RXDPATH_RST	GENMASK(23, 0)
 
 /**
  * struct axidma_bd - Axi Dma buffer descriptor layout
@@ -809,7 +738,6 @@ struct axidma_bd {
  *		   Otherwise reserved.
  * @tx_skb:	  Transmit skb address
  * @tx_desc_mapping: Tx Descriptor DMA mapping type.
- * @page:	page buffer to access the data passed by GRO packet
  */
 struct aximcdma_bd {
 	phys_addr_t next;	/* Physical address of next buffer descriptor */
@@ -834,7 +762,6 @@ struct aximcdma_bd {
 	u32 ptp_tx_ts_tag;
 	phys_addr_t tx_skb;
 	u32 tx_desc_mapping;
-	struct page *page;
 } __aligned(XAXIDMA_BD_MINIMUM_ALIGNMENT);
 
 #define XAE_NUM_MISC_CLOCKS 3
@@ -856,15 +783,11 @@ struct aximcdma_bd {
 #define GPIO_GLOBAL_INT_MASK	BIT(31)
 #define AXI_GPIO_INT		"axigpio"
 
-struct ethtool_rx_fs_list {
-	struct list_head list;
-	unsigned int count;
-};
-
 /**
  * struct axienet_local - axienet private per device data
  * @ndev:	Pointer for net_device to which it will be attached.
  * @dev:	Pointer to device structure
+ * @phy_node:	Pointer to device node structure
  * @phylink:	Pointer to phylink instance
  * @phylink_config: phylink configuration settings
  * @pcs_phy:	Reference to PCS/PMA PHY if used
@@ -922,24 +845,13 @@ struct ethtool_rx_fs_list {
  * @weight:   MCDMA Channel weight value to be configured for.
  * @dma_mask: Specify the width of the DMA address space.
  * @usxgmii_rate: USXGMII PHY speed.
- * @max_speed: Maximum possible MAC speed.
+ * @mrmac_rate: MRMAC speed.
  * @gt_pll: Common GT PLL mask control register space.
  * @gt_ctrl: GT speed and reset control register space.
- * @gds_gt_ctrl:	GPIO descriptor array for GT control.
- * @gds_gt_rx_dpath: GPIO descriptor array for GT Rx datapath reset.
- * @gds_gt_tx_dpath: GPIO descriptor array for GT Tx datapath reset.
- * @gds_gt_rsts: GPIO descriptor array for GT serdes and core reset.
- * @gds_gt_tx_reset_done: GPIO descriptor array to get Tx reset status.
- * @gds_gt_rx_reset_done: GPIO descriptor array to get Rx reset status.
  * @phc_index: Index to corresponding PTP clock used.
  * @gt_lane: MRMAC GT lane index used.
  * @switch_lock: Spinlock for switchable IP.
- * @eoe_regs: Ethernet offload IP base address.
- * @eoe_connected: Tells whether ethernet offload IP is connected to Ethernet IP.
- * @eoe_features: EOE IP supported configuration.
- * @inetaddr_notifier: Notifier callback function for specific event.
- * @rx_fs_list: RX queue filter rule set.
- * @assigned_rx_port: Ports assigned to GRO Queue.
+ * @restart_work: delayable work queue.
  */
 struct axienet_local {
 	struct net_device *ndev;
@@ -1020,24 +932,15 @@ struct axienet_local {
 	u8 dma_mask;
 	u32 usxgmii_rate;
 
-	u32 max_speed;		/* Max MAC speed */
+	u32 mrmac_rate;		/* MRMAC speed */
 	void __iomem *gt_pll;	/* Common GT PLL mask control register space */
 	void __iomem *gt_ctrl;	/* GT speed and reset control register space */
-	struct gpio_descs *gds_gt_ctrl;
-	struct gpio_descs *gds_gt_rx_dpath;
-	struct gpio_descs *gds_gt_tx_dpath;
-	struct gpio_descs *gds_gt_rsts;
-	struct gpio_descs *gds_gt_tx_reset_done;
-	struct gpio_descs *gds_gt_rx_reset_done;
 	u32 phc_index;		/* Index to corresponding PTP clock used  */
 	u32 gt_lane;		/* MRMAC GT lane index used */
 	spinlock_t switch_lock;	/* To protect Link training programming from multiple context */
-	void __iomem *eoe_regs;
-	bool eoe_connected;
-	u32 eoe_features;
-	struct notifier_block inetaddr_notifier;
-	struct ethtool_rx_fs_list rx_fs_list;
-	u16 assigned_rx_port[XAE_MAX_QUEUES];
+	struct delayed_work restart_work;
+	void __iomem *gpio_regs;/* CMAC AXI-GPIO register space*/
+	int gpio_irq;		/* CMAC AXI-GPIO irq*/
 };
 
 /**
@@ -1361,21 +1264,21 @@ struct axienet_dma_q {
 /**
  * enum axienet_ip_type - AXIENET IP/MAC type.
  *
- * @XAXIENET_1_2p5G:	 IP is 1G/2.5G
+ * @XAXIENET_1G:	 IP is 1G MAC
+ * @XAXIENET_2_5G:	 IP type is 2.5G MAC.
  * @XAXIENET_LEGACY_10G: IP type is legacy 10G MAC.
  * @XAXIENET_10G_25G:	 IP type is 10G/25G MAC(XXV MAC).
  * @XAXIENET_MRMAC:	 IP type is hardened Multi Rate MAC (MRMAC).
  * @XAXIENET_1G_10G_25G: IP type is 1G/10G/25G MAC.
- * @XAXIENET_DCMAC: IP type is 600G Channelized Multirate Ethernet (DCMAC)
  *
  */
 enum axienet_ip_type {
-	XAXIENET_1_2p5G = 0,
+	XAXIENET_1G = 0,
+	XAXIENET_2_5G,
 	XAXIENET_LEGACY_10G,
 	XAXIENET_10G_25G,
 	XAXIENET_MRMAC,
 	XAXIENET_1G_10G_25G,
-	XAXIENET_DCMAC,
 	XAXIENET_100G,
 	XAXIENET_MRMAC_100G,
 };
@@ -1388,11 +1291,10 @@ struct axienet_config {
 			struct clk **dclk);
 	u32 tx_ptplen;
 	u8 ts_header_len;
-	int (*gt_reset)(struct net_device *ndev);
 };
 
 /**
- * struct axienet_option - Used to set axi ethernet hardware options
+ * struct axiethernet_option - Used to set axi ethernet hardware options
  * @opt:	Option to be set.
  * @reg:	Register offset to be written for setting the option
  * @m_or:	Mask to be ORed for setting the option in the register
diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index 740a3d664463..4f659e730012 100755
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@ -47,12 +47,9 @@
 #include <linux/random.h>
 #include <net/sock.h>
 #include <linux/ptp/ptp_xilinx.h>
-#include <linux/gpio/consumer.h>
-#include <linux/inetdevice.h>
-#include <linux/netdevice.h>
+#include <linux/workqueue.h>
 
 #include "xilinx_axienet.h"
-#include "xilinx_axienet_eoe.h"
 
 /* Descriptors defines for Tx and Rx DMA */
 #define RX_BD_NUM_DEFAULT		128
@@ -72,7 +69,7 @@
 #define MRMAC_TS_HEADER_WORDS	(MRMAC_TS_HEADER_LEN / 4)
 #define NS_PER_SEC              1000000000ULL /* Nanoseconds per second */
 
-#define	DELAY_1MS	1	/* 1 msecs delay*/
+#define MRMAC_RESET_DELAY	1 /* Delay in msecs*/
 
 /* IEEE1588 Message Type field values  */
 #define PTP_TYPE_SYNC		0
@@ -97,6 +94,14 @@ EXPORT_SYMBOL(mrmac_pll_reg);
 int mrmac_pll_rst;
 EXPORT_SYMBOL(mrmac_pll_rst);
 static void xcmac_100G_reset(struct axienet_local *xcmac_dev);
+#if 0 //Paddy Hayes
+int axienet_open(struct net_device *ndev);
+int axienet_stop(struct net_device *ndev);
+int axienet_change_mtu(struct net_device *ndev, int new_mtu);
+int netdev_set_mac_address(struct net_device *ndev, void *p);
+int axienet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+#endif
+
 
 /* Option table for setting up Axi Ethernet hardware options */
 static struct axienet_option axienet_options[] = {
@@ -230,10 +235,7 @@ void axienet_dma_bd_release(struct net_device *ndev)
 #endif
 	for_each_rx_dma_queue(lp, i) {
 #ifdef CONFIG_AXIENET_HAS_MCDMA
-		if (axienet_eoe_is_channel_gro(lp, lp->dq[i]))
-			axienet_eoe_mcdma_gro_bd_free(ndev, lp->dq[i]);
-		else
-			axienet_mcdma_rx_bd_free(ndev, lp->dq[i]);
+		axienet_mcdma_rx_bd_free(ndev, lp->dq[i]);
 #else
 		axienet_bd_free(ndev, lp->dq[i]);
 #endif
@@ -317,7 +319,8 @@ void axienet_set_mac_address(struct net_device *ndev,
 	if (!is_valid_ether_addr(ndev->dev_addr))
 		eth_hw_addr_random(ndev);
 
-	if (lp->axienet_config->mactype != XAXIENET_1_2p5G)
+	if (lp->axienet_config->mactype != XAXIENET_1G &&
+	    lp->axienet_config->mactype != XAXIENET_2_5G)
 		return;
 
 	/* Set up unicast MAC address filter set its mac address */
@@ -369,8 +372,7 @@ void axienet_set_multicast_list(struct net_device *ndev)
 	u32 reg, af0reg, af1reg;
 	struct axienet_local *lp = netdev_priv(ndev);
 
-	if (lp->axienet_config->mactype != XAXIENET_1_2p5G ||
-	    lp->eth_hasnobuf)
+	if (lp->axienet_config->mactype != XAXIENET_1G || lp->eth_hasnobuf)
 		return;
 
 	if (ndev->flags & (IFF_ALLMULTI | IFF_PROMISC) ||
@@ -557,10 +559,10 @@ static inline void axienet_mrmac_reset(struct axienet_local *lp)
 	val |= (MRMAC_RX_SERDES_RST_MASK | MRMAC_TX_SERDES_RST_MASK |
 		MRMAC_RX_RST_MASK | MRMAC_TX_RST_MASK);
 	axienet_iow(lp, MRMAC_RESET_OFFSET, val);
-	mdelay(DELAY_1MS);
+	mdelay(MRMAC_RESET_DELAY);
 
 	reg = axienet_ior(lp, MRMAC_MODE_OFFSET);
-	if (lp->max_speed == SPEED_25000) {
+	if (lp->mrmac_rate == SPEED_25000) {
 		reg &= ~MRMAC_CTL_RATE_CFG_MASK;
 		reg |= MRMAC_CTL_DATA_RATE_25G;
 		reg |= (MRMAC_CTL_AXIS_CFG_25G_IND << MRMAC_CTL_AXIS_CFG_SHIFT);
@@ -584,220 +586,6 @@ static inline void axienet_mrmac_reset(struct axienet_local *lp)
 	axienet_iow(lp, MRMAC_RESET_OFFSET, val);
 }
 
-static ulong dcmac_gt_tx_reset_status(struct axienet_local *lp)
-{
-	ulong val;
-
-	gpiod_get_array_value_cansleep(lp->gds_gt_tx_reset_done->ndescs,
-				       lp->gds_gt_tx_reset_done->desc,
-				       lp->gds_gt_tx_reset_done->info, &val);
-	return val;
-}
-
-static ulong dcmac_gt_rx_reset_status(struct axienet_local *lp)
-{
-	ulong val;
-
-	gpiod_get_array_value_cansleep(lp->gds_gt_rx_reset_done->ndescs,
-				       lp->gds_gt_rx_reset_done->desc,
-				       lp->gds_gt_rx_reset_done->info, &val);
-	return val;
-}
-
-static void dcmac_init(struct axienet_local *lp)
-{
-	u32 val, val_tx, val_rx;
-
-	val = (DCMAC_TX_ACTV_PRT_ALL_MASK | DCMAC_RX_ACTV_PRT_ALL_MASK |
-		DCMAC_RX_ERR_IND_STD_MASK | DCMAC_TX_FEC_UNIQUE_FLIP_MASK |
-		DCMAC_RX_FEC_UNIQUE_FLIP_MASK);
-	axienet_iow(lp, DCMAC_G_MODE_OFFSET, val);
-
-	val = (DCMAC_CH_RX_FCS_MASK | DCMAC_CH_RX_PREAMBLE_MASK |
-		DCMAC_RX_IGNR_INRANGE_MASK | DCMAC_RX_MAX_PKT_LEN_MASK);
-	axienet_iow(lp, DCMAC_CH_CFG_RX_OFFSET, val);
-
-	val = (DCMAC_CH_TX_FCS_MASK | DCMAC_CH_TX_IPG_MASK);
-	axienet_iow(lp, DCMAC_CH_CFG_TX_OFFSET, val);
-
-	/* Set data rate and FEC mode */
-	val_tx = 0x0;
-	val_rx = 0x0;
-
-	switch (lp->max_speed) {
-	case SPEED_100000:
-		val_tx &= DCMAC_P_SPEED_100G_MASK;
-		val_rx &= DCMAC_P_SPEED_100G_MASK;
-		/* 100G KR4 FEC operating mode */
-		val_tx |= DCMAC_CH_MD_FEC_KR4;
-		val_rx |= DCMAC_CH_MD_FEC_KR4;
-		break;
-	case SPEED_200000:
-		val_tx |= DCMAC_P_SPEED_200G_MASK;
-		val_rx |= DCMAC_P_SPEED_200G_MASK;
-		/* 200G FEC operating mode */
-		val_tx |= DCMAC_CH_MD_FEC_200G;
-		val_rx |= DCMAC_CH_MD_FEC_200G;
-		break;
-	case SPEED_400000:
-		val_tx |= DCMAC_P_SPEED_400G_MASK;
-		val_rx |= DCMAC_P_SPEED_400G_MASK;
-		/* 400G FEC operating mode */
-		val_tx |= DCMAC_CH_MD_FEC_400G;
-		val_rx |= DCMAC_CH_MD_FEC_400G;
-
-		break;
-	default:
-		break;
-	}
-	/* pm_tick triggered by internal registers for channel statistics */
-	val_tx |= DCMAC_CH_TXMD_PM_TICK_INTERNAL_MASK;
-	val_rx |= DCMAC_CH_RXMD_PM_TICK_INTERNAL_MASK;
-
-	axienet_iow(lp, DCMAC_CH_MODE_TX_OFFSET, val_tx);
-	axienet_iow(lp, DCMAC_CH_MODE_RX_OFFSET, val_rx);
-}
-
-static ulong dcmac_rx_phy_status(struct net_device *ndev)
-{
-	struct axienet_local *lp = netdev_priv(ndev);
-	ulong val;
-	int ret;
-
-	/* Reset GT Rx datapath */
-	val = DCMAC_GT_RXDPATH_RST;
-	gpiod_set_array_value_cansleep(lp->gds_gt_rx_dpath->ndescs,
-				       lp->gds_gt_rx_dpath->desc,
-				       lp->gds_gt_rx_dpath->info, &val);
-	mdelay(DELAY_1MS);
-	val = 0;
-	gpiod_set_array_value_cansleep(lp->gds_gt_rx_dpath->ndescs,
-				       lp->gds_gt_rx_dpath->desc,
-				       lp->gds_gt_rx_dpath->info, &val);
-
-	/* Tx and Rx serdes reset */
-	gpiod_set_array_value_cansleep(lp->gds_gt_rsts->ndescs,
-				       lp->gds_gt_rsts->desc,
-				       lp->gds_gt_rsts->info, &val);
-	mdelay(DELAY_1MS);
-
-	ret = readx_poll_timeout(dcmac_gt_rx_reset_status, lp, val,
-				 val == (ulong)DCMAC_GT_RESET_DONE_MASK, 10,
-				 100 * DELAY_OF_ONE_MILLISEC);
-	if (ret) {
-		netdev_err(ndev,
-			   "GT RX reset done not achieved (Status = 0x%lx)\n",
-			   val);
-		return ret;
-	}
-
-	mdelay(DELAY_1MS);
-	/* Assert and deassert DCMAC Rx port reset */
-	axienet_iow(lp, DCMAC_P_CTRL_RX_OFFSET,
-		    DCMAC_P_CTRL_CLR_SERDES);
-	mdelay(DELAY_1MS);
-	axienet_iow(lp, DCMAC_P_CTRL_RX_OFFSET, 0);
-
-	/* Delay of 2ms is needed */
-	mdelay(2 * DELAY_1MS);
-
-	/* Clear previous status */
-	axienet_iow(lp, DCMAC_STS_RX_PHY_OFFSET, 0xFFFFFFFF);
-	mdelay(DELAY_1MS);
-
-	/* Read phy status for PCS alignment, Rx status and Block lock */
-	val = axienet_ior(lp, DCMAC_STS_RX_PHY_OFFSET);
-	return val;
-}
-
-static void dcmac_assert_reset(struct net_device *ndev)
-{
-	struct axienet_local *lp = netdev_priv(ndev);
-	u32 val;
-
-	val = DCMAC_G_CTRL_RESET_ALL;
-	axienet_iow(lp, DCMAC_G_CTRL_RX_OFFSET, val);
-	axienet_iow(lp, DCMAC_G_CTRL_TX_OFFSET, val);
-	val = DCMAC_P_CTRL_CLEAR_ALL;
-	axienet_iow(lp, DCMAC_P_CTRL_RX_OFFSET, val);
-	axienet_iow(lp, DCMAC_P_CTRL_TX_OFFSET, val);
-
-	/* Assert channel resets */
-	val = DCMAC_CH_CTRL_CLEAR_STATE;
-	axienet_iow(lp, DCMAC_CH_CTRL_RX_OFFSET, val);
-	axienet_iow(lp, DCMAC_CH_CTRL_TX_OFFSET, val);
-	mdelay(DELAY_1MS);
-	val = DCMAC_P_CTRL_CLEAR_ALL;
-	axienet_iow(lp, DCMAC_P_CTRL_RX_OFFSET, val);
-	axienet_iow(lp, DCMAC_P_CTRL_TX_OFFSET, val);
-}
-
-static void dcmac_release_reset(struct net_device *ndev)
-{
-	struct axienet_local *lp = netdev_priv(ndev);
-
-	/* Release DCMAC global port and channel reset */
-	axienet_iow(lp, DCMAC_G_CTRL_TX_OFFSET, DCMAC_RELEASE_RESET);
-	axienet_iow(lp, DCMAC_G_CTRL_RX_OFFSET, DCMAC_RELEASE_RESET);
-	axienet_iow(lp, DCMAC_P_CTRL_TX_OFFSET, DCMAC_RELEASE_RESET);
-	axienet_iow(lp, DCMAC_P_CTRL_RX_OFFSET, DCMAC_RELEASE_RESET);
-	mdelay(DELAY_1MS);
-	axienet_iow(lp, DCMAC_CH_CTRL_TX_OFFSET, DCMAC_RELEASE_RESET);
-	axienet_iow(lp, DCMAC_CH_CTRL_RX_OFFSET, DCMAC_RELEASE_RESET);
-	mdelay(DELAY_1MS);
-}
-
-static int dcmac_gt_reset(struct net_device *ndev)
-{
-	struct axienet_local *lp = netdev_priv(ndev);
-	ulong val_gpio;
-	u32 ret;
-
-	val_gpio = (DCMAC_GT_RESET_ALL | DCMAC_GT_TX_PRECURSOR |
-	       DCMAC_GT_TX_POSTCURSOR | DCMAC_GT_MAINCURSOR);
-	gpiod_set_array_value_cansleep(lp->gds_gt_ctrl->ndescs,
-				       lp->gds_gt_ctrl->desc,
-				       lp->gds_gt_ctrl->info, &val_gpio);
-	mdelay(DELAY_1MS);
-
-	val_gpio &= ~DCMAC_GT_RESET_ALL;
-	gpiod_set_array_value_cansleep(lp->gds_gt_ctrl->ndescs,
-				       lp->gds_gt_ctrl->desc,
-				       lp->gds_gt_ctrl->info, &val_gpio);
-
-	/* Ensure the GT TX Datapath Reset is not asserted */
-	val_gpio = 0;
-	gpiod_set_array_value_cansleep(lp->gds_gt_tx_dpath->ndescs,
-				       lp->gds_gt_tx_dpath->desc,
-				       lp->gds_gt_tx_dpath->info, &val_gpio);
-
-	mdelay(DELAY_1MS);
-
-	/* Check for GT TX RESET DONE */
-	ret = readx_poll_timeout(dcmac_gt_tx_reset_status, lp, val_gpio,
-				 val_gpio == (ulong)DCMAC_GT_RESET_DONE_MASK,
-				 10, 100 * DELAY_OF_ONE_MILLISEC);
-	if (ret) {
-		netdev_err(ndev,
-			   "GT TX Reset Done not achieved (Status = 0x%lx)\n",
-			   val_gpio);
-		return ret;
-	}
-
-	/* Check for GT RX RESET DONE */
-	ret = readx_poll_timeout(dcmac_gt_rx_reset_status, lp, val_gpio,
-				 val_gpio == (ulong)DCMAC_GT_RESET_DONE_MASK, 10,
-				 100 * DELAY_OF_ONE_MILLISEC);
-	if (ret) {
-		netdev_err(ndev,
-			   "GT RX Reset Done not achieved (Status = 0x%lx)\n",
-			   val_gpio);
-		return ret;
-	}
-
-	return ret;
-}
-
 static inline int axienet_mrmac_gt_reset(struct net_device *ndev)
 {
 	struct axienet_local *lp = netdev_priv(ndev);
@@ -809,7 +597,7 @@ static inline int axienet_mrmac_gt_reset(struct net_device *ndev)
 			iowrite32(MRMAC_GT_RST_ALL_MASK, (lp->gt_ctrl +
 				  (MRMAC_GT_LANE_OFFSET * i) +
 				  MRMAC_GT_CTRL_OFFSET));
-			mdelay(DELAY_1MS);
+			mdelay(MRMAC_RESET_DELAY);
 			iowrite32(0, (lp->gt_ctrl + (MRMAC_GT_LANE_OFFSET * i) +
 				      MRMAC_GT_CTRL_OFFSET));
 		}
@@ -825,7 +613,7 @@ static inline int axienet_mrmac_gt_reset(struct net_device *ndev)
 		mrmac_pll_rst = 1;
 	}
 
-	if (lp->max_speed == SPEED_25000)
+	if (lp->mrmac_rate == SPEED_25000)
 		iowrite32(MRMAC_GT_25G_MASK, (lp->gt_ctrl +
 			  MRMAC_GT_LANE_OFFSET * lp->gt_lane +
 			  MRMAC_GT_RATE_OFFSET));
@@ -837,27 +625,10 @@ static inline int axienet_mrmac_gt_reset(struct net_device *ndev)
 	iowrite32(MRMAC_GT_RST_RX_MASK | MRMAC_GT_RST_TX_MASK,
 		  (lp->gt_ctrl + MRMAC_GT_LANE_OFFSET * lp->gt_lane +
 		  MRMAC_GT_CTRL_OFFSET));
-	mdelay(DELAY_1MS);
+	mdelay(MRMAC_RESET_DELAY);
 	iowrite32(0, (lp->gt_ctrl + MRMAC_GT_LANE_OFFSET * lp->gt_lane +
 		  MRMAC_GT_CTRL_OFFSET));
-	mdelay(DELAY_1MS);
-
-	return 0;
-}
-
-static inline int xxv_gt_reset(struct net_device *ndev)
-{
-	struct axienet_local *lp = netdev_priv(ndev);
-	u32 val;
-
-	val = axienet_ior(lp, XXV_GT_RESET_OFFSET);
-	val |= XXV_GT_RESET_MASK;
-	axienet_iow(lp, XXV_GT_RESET_OFFSET, val);
-	/* Wait for 1ms for GT reset to complete as per spec */
-	mdelay(DELAY_1MS);
-	val = axienet_ior(lp, XXV_GT_RESET_OFFSET);
-	val &= ~XXV_GT_RESET_MASK;
-	axienet_iow(lp, XXV_GT_RESET_OFFSET, val);
+	mdelay(MRMAC_RESET_DELAY);
 
 	return 0;
 }
@@ -990,6 +761,19 @@ static int axienet_device_reset(struct net_device *ndev)
 	struct axienet_dma_q *q;
 	u32 i;
 
+	if (lp->axienet_config->mactype == XAXIENET_10G_25G ||
+	    lp->axienet_config->mactype == XAXIENET_1G_10G_25G) {
+		/* Reset the XXV MAC */
+		val = axienet_ior(lp, XXV_GT_RESET_OFFSET);
+		val |= XXV_GT_RESET_MASK;
+		axienet_iow(lp, XXV_GT_RESET_OFFSET, val);
+		/* Wait for 1ms for GT reset to complete as per spec */
+		mdelay(1);
+		val = axienet_ior(lp, XXV_GT_RESET_OFFSET);
+		val &= ~XXV_GT_RESET_MASK;
+		axienet_iow(lp, XXV_GT_RESET_OFFSET, val);
+	}
+
 	if (lp->axienet_config->mactype == XAXIENET_MRMAC) {
 		/* Reset MRMAC */
 		axienet_mrmac_reset(lp);
@@ -997,24 +781,13 @@ static int axienet_device_reset(struct net_device *ndev)
 		if (axienet_mrmac_gt_reset(ndev))
 			return 0;
 	}
-
-
-
-
 	if (lp->axienet_config->mactype == XAXIENET_MRMAC_100G) {
 		/* Reset MRMAC 100G*/
 		axienet_mrmac_100g_reset(lp);
 
 		if (axienet_mrmac_100g_gt_reset(ndev))
-			return 0;
-	}
-
-	if (lp->axienet_config->gt_reset) {
-		ret = lp->axienet_config->gt_reset(ndev);
-		if (ret)
-			return ret;
+			return 0 ;
 	}
-
 	for_each_rx_dma_queue(lp, i) {
 		q = lp->dq[i];
 		__axienet_device_reset(q);
@@ -1052,8 +825,7 @@ static int axienet_device_reset(struct net_device *ndev)
 	    lp->axienet_config->mactype != XAXIENET_100G &&
 	    lp->axienet_config->mactype != XAXIENET_MRMAC_100G &&
 	    lp->axienet_config->mactype != XAXIENET_1G_10G_25G &&
-	    lp->axienet_config->mactype != XAXIENET_MRMAC &&
-	    lp->axienet_config->mactype != XAXIENET_DCMAC) {
+	    lp->axienet_config->mactype != XAXIENET_MRMAC) {
 		axienet_status = axienet_ior(lp, XAE_RCW1_OFFSET);
 		axienet_status &= ~XAE_RCW1_RX_MASK;
 		axienet_iow(lp, XAE_RCW1_OFFSET, axienet_status);
@@ -1111,7 +883,7 @@ static int axienet_device_reset(struct net_device *ndev)
 	}
 #endif
 
-	if (lp->axienet_config->mactype == XAXIENET_1_2p5G &&
+	if (lp->axienet_config->mactype == XAXIENET_1G &&
 	    !lp->eth_hasnobuf) {
 		axienet_status = axienet_ior(lp, XAE_IP_OFFSET);
 		if (axienet_status & XAE_INT_RXRJECT_MASK)
@@ -1131,37 +903,16 @@ static int axienet_device_reset(struct net_device *ndev)
 		    lp->axienet_config->mactype != XAXIENET_MRMAC_100G)
 			axienet_iow(lp, XAE_FCC_OFFSET, XAE_FCC_FCRX_MASK);
 	}
-
-	if (lp->axienet_config->setoptions){
-		if (lp->axienet_config->mactype != XAXIENET_100G &&
-	    	lp->axienet_config->mactype != XAXIENET_MRMAC_100G) {
-			lp->axienet_config->setoptions(ndev, lp->options &
-				      	 ~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
-	}
+	if (lp->axienet_config->mactype != XAXIENET_100G &&
+	    lp->axienet_config->mactype != XAXIENET_MRMAC_100G) {
+		lp->axienet_config->setoptions(ndev, lp->options &
+				       ~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
 
 	axienet_set_mac_address(ndev, NULL);
 	axienet_set_multicast_list(ndev);
-	if (lp->axienet_config->mactype == XAXIENET_DCMAC) {
-		dcmac_assert_reset(ndev);
-		dcmac_init(lp);
-		dcmac_release_reset(ndev);
-
-		/* Check for alignment */
-		ret = readx_poll_timeout(dcmac_rx_phy_status, ndev, val,
-					 (val > 0) &&
-					 (val & DCMAC_RXPHY_RX_STS_MASK) &&
-					 (val & DCMAC_RXPHY_RX_ALIGN_MASK),
-					 10, 100 * DELAY_OF_ONE_MILLISEC);
-
-		if (ret) {
-			netdev_err(ndev, "Alignment not achieved. Failed to reset DCMAC\n");
-			return -ENODEV;
-		}
+	lp->axienet_config->setoptions(ndev, lp->options);
 	}
 
-	if (lp->axienet_config->setoptions)
-		lp->axienet_config->setoptions(ndev, lp->options);
-
 	netif_trans_update(ndev);
 
 	return 0;
@@ -1523,7 +1274,8 @@ static int axienet_create_tsheader(u8 *buf, u8 msg_type,
 		buf[3] = (cur_p->ptp_tx_ts_tag >> 8) & 0xFF;
 	}
 
-	if (lp->axienet_config->mactype == XAXIENET_1_2p5G) {
+	if (lp->axienet_config->mactype == XAXIENET_1G ||
+	    lp->axienet_config->mactype == XAXIENET_2_5G) {
 		memcpy(&val, buf, AXIENET_TS_HEADER_LEN);
 		swab64s(&val);
 		memcpy(buf, &val, AXIENET_TS_HEADER_LEN);
@@ -1700,8 +1452,7 @@ static int axienet_queue_xmit(struct sk_buff *skb,
 	    lp->axienet_config->mactype == XAXIENET_100G ||
 	    lp->axienet_config->mactype == XAXIENET_MRMAC_100G ||
 	    lp->axienet_config->mactype == XAXIENET_1G_10G_25G ||
-	    lp->axienet_config->mactype == XAXIENET_MRMAC ||
-	    lp->axienet_config->mactype == XAXIENET_DCMAC) {
+	    lp->axienet_config->mactype == XAXIENET_MRMAC) {
 		/* Need to manually pad the small frames in case of XXV MAC
 		 * because the pad field is not added by the IP. We must present
 		 * a packet that meets the minimum length to the IP core.
@@ -1714,6 +1465,7 @@ static int axienet_queue_xmit(struct sk_buff *skb,
 			return NETDEV_TX_OK;
 		}
 	}
+
 	num_frag = skb_shinfo(skb)->nr_frags;
 
 	q = lp->dq[map];
@@ -1752,8 +1504,7 @@ static int axienet_queue_xmit(struct sk_buff *skb,
 #endif
 
 	if (skb->ip_summed == CHECKSUM_PARTIAL && !lp->eth_hasnobuf &&
-	    lp->axienet_config->mactype == XAXIENET_1_2p5G &&
-	    !(lp->eoe_connected)) {
+	    lp->axienet_config->mactype == XAXIENET_1G) {
 		if (lp->features & XAE_FEATURE_FULL_TX_CSUM) {
 			/* Tx Full Checksum Offload Enabled */
 			cur_p->app0 |= 2;
@@ -1766,8 +1517,7 @@ static int axienet_queue_xmit(struct sk_buff *skb,
 		}
 	} else if (skb->ip_summed == CHECKSUM_UNNECESSARY &&
 		   !lp->eth_hasnobuf &&
-		   (lp->axienet_config->mactype == XAXIENET_1_2p5G) &&
-		   !(lp->eoe_connected)) {
+		   (lp->axienet_config->mactype == XAXIENET_1G)) {
 		cur_p->app0 |= 2; /* Tx Full Checksum Offload Enabled */
 	}
 
@@ -1802,18 +1552,6 @@ static int axienet_queue_xmit(struct sk_buff *skb,
 	}
 	cur_p->tx_desc_mapping = DESC_DMA_MAP_SINGLE;
 
-	/* Update the APP fields for UDP segmentation by HW, if it is enabled.
-	 * This automatically enables the checksum calculation by HW.
-	 * If UDP segmentation by HW is not supported, then update the APP fields for
-	 * checksum calculation by HW, if it is enabled.
-	 */
-#ifdef CONFIG_AXIENET_HAS_MCDMA
-	if (ndev->hw_features & NETIF_F_GSO_UDP_L4)
-		axienet_eoe_config_hwgso(ndev, skb, cur_p);
-	else if (ndev->hw_features & NETIF_F_IP_CSUM)
-		axienet_eoe_config_hwcso(ndev, cur_p);
-#endif
-
 	for (ii = 0; ii < num_frag; ii++) {
 		u32 len;
 		skb_frag_t *frag;
@@ -1946,7 +1684,7 @@ static int axienet_recv(struct net_device *ndev, int budget,
 		 */
 		if (likely(skb)) {
 			if (lp->eth_hasnobuf ||
-			    lp->axienet_config->mactype != XAXIENET_1_2p5G)
+			    lp->axienet_config->mactype != XAXIENET_1G)
 				length = cur_p->status & XAXIDMA_BD_STS_ACTUAL_LEN_MASK;
 			else
 				length = cur_p->app4 & 0x0000FFFF;
@@ -1962,7 +1700,8 @@ static int axienet_recv(struct net_device *ndev, int budget,
 				u64 time64;
 				struct skb_shared_hwtstamps *shhwtstamps;
 
-				if (lp->axienet_config->mactype == XAXIENET_1_2p5G) {
+				if (lp->axienet_config->mactype == XAXIENET_1G ||
+				    lp->axienet_config->mactype == XAXIENET_2_5G) {
 					/* The first 8 bytes will be the timestamp */
 					memcpy(&sec, &skb->data[0], 4);
 					memcpy(&nsec, &skb->data[4], 4);
@@ -1991,7 +1730,7 @@ static int axienet_recv(struct net_device *ndev, int budget,
 
 			/* if we're doing Rx csum offload, set it up */
 			if (lp->features & XAE_FEATURE_FULL_RX_CSUM &&
-			    lp->axienet_config->mactype == XAXIENET_1_2p5G &&
+			    lp->axienet_config->mactype == XAXIENET_1G &&
 			    !lp->eth_hasnobuf) {
 				csumstatus = (cur_p->app2 &
 					      XAE_FULL_CSUM_STATUS_MASK) >> 3;
@@ -2002,7 +1741,7 @@ static int axienet_recv(struct net_device *ndev, int budget,
 			} else if ((lp->features & XAE_FEATURE_PARTIAL_RX_CSUM) != 0 &&
 				   skb->protocol == htons(ETH_P_IP) &&
 				   skb->len > 64 && !lp->eth_hasnobuf &&
-				   lp->axienet_config->mactype == XAXIENET_1_2p5G) {
+				   lp->axienet_config->mactype == XAXIENET_1G) {
 				skb->csum = be32_to_cpu(cur_p->app3 & 0xFFFF);
 				skb->ip_summed = CHECKSUM_COMPLETE;
 			}
@@ -2093,12 +1832,7 @@ int xaxienet_rx_poll(struct napi_struct *napi, int quota)
 			dev_err(lp->dev, "Rx error 0x%x\n\r", status);
 			break;
 		}
-
-		if (axienet_eoe_is_channel_gro(lp, q))
-			work_done += axienet_eoe_recv_gro(lp->ndev, quota - work_done, q);
-		else
-			work_done += axienet_recv(lp->ndev, quota - work_done, q);
-
+		work_done += axienet_recv(lp->ndev, quota - work_done, q);
 		status = axienet_dma_in32(q, XMCDMA_CHAN_SR_OFFSET(q->chan_id) +
 					  q->rx_offset);
 	}
@@ -2203,7 +1937,6 @@ static irqreturn_t axigpio_irq_handler(int irq, void *ndev)
 	iowrite32(GPIO_INT_CHN1_MASK, lp->gpio_regs + GPIO_INT_STS_REG);
 	return IRQ_HANDLED;
 }
-
 static void
 axienet_config_autoneg_link_training(struct axienet_local *lp, unsigned int speed_config)
 {
@@ -2254,6 +1987,25 @@ axienet_config_autoneg_link_training(struct axienet_local *lp, unsigned int spee
 	}
 }
 
+static void speed_monitor_thread(struct work_struct *work)
+{
+	struct axienet_local *lp = container_of(work, struct axienet_local, restart_work.work);
+	static int lp_speed, dut_speed;
+
+	spin_lock(&lp->switch_lock);
+	lp_speed = axienet_ior(lp, XXVS_AN_LP_STATUS_OFFSET);
+	dut_speed = axienet_ior(lp, XXVS_AN_ABILITY_OFFSET);
+
+	if ((lp_speed & dut_speed) == XXVS_SPEED_1G)
+		axienet_iow(lp, XXVS_LT_CTL_OFFSET, 0);
+
+	if ((lp_speed & dut_speed) == XXVS_SPEED_10G)
+		axienet_iow(lp, XXVS_LT_CTL_OFFSET, 1);
+
+	spin_unlock(&lp->switch_lock);
+	schedule_delayed_work(&lp->restart_work, msecs_to_jiffies(200));
+}
+
 /**
  * axienet_open - Driver open routine.
  * @ndev:	Pointer to net_device structure
@@ -2430,7 +2182,7 @@ static int axienet_open(struct net_device *ndev)
 		/* Reset MRMAC */
 		axienet_mrmac_reset(lp);
 
-		mdelay(DELAY_1MS);
+		mdelay(MRMAC_RESET_DELAY);
 		/* Check for block lock bit to be set. This ensures that
 		 * MRMAC ethernet IP is functioning normally.
 		 */
@@ -2458,7 +2210,7 @@ static int axienet_open(struct net_device *ndev)
 			ret = -ENODEV;
 			goto err_eth_irq;
 		}
-		netdev_info(ndev, "MRMAC setup at %d\n", lp->max_speed);
+		netdev_info(ndev, "MRMAC setup at %d\n", lp->mrmac_rate);
 		axienet_iow(lp, MRMAC_TICK_OFFSET, MRMAC_TICK_TRIGGER);
 	}
 
@@ -2500,7 +2252,7 @@ static int axienet_open(struct net_device *ndev)
 	}
 
 	/* Enable interrupts for Axi Ethernet core (if defined) */
-	if (!lp->eth_hasnobuf && lp->axienet_config->mactype == XAXIENET_1_2p5G) {
+	if (!lp->eth_hasnobuf && lp->axienet_config->mactype == XAXIENET_1G) {
 		ret = request_irq(lp->eth_irq, axienet_eth_irq, IRQF_SHARED,
 				  ndev->name, ndev);
 		if (ret)
@@ -2517,6 +2269,12 @@ static int axienet_open(struct net_device *ndev)
 		}
 	}
 
+	if (lp->axienet_config->mactype == XAXIENET_1G_10G_25G) {
+		axienet_config_autoneg_link_training(lp,
+						     (XXVS_AN_10G_ABILITY_MASK
+						     | XXVS_AN_1G_ABILITY_MASK));
+		schedule_delayed_work(&lp->restart_work, msecs_to_jiffies(500));
+	}
 
 	/* If Runtime speed switching supported */
 	if (lp->axienet_config->mactype == XAXIENET_10G_25G &&
@@ -2526,7 +2284,7 @@ static int axienet_open(struct net_device *ndev)
 			    XXV_AN_10G_ABILITY_MASK | XXV_AN_25G_ABILITY_MASK);
 		axienet_iow(lp, XXVS_AN_CTL1_OFFSET,
 			    (XXVS_AN_ENABLE_MASK | XXVS_AN_NONCE_SEED));
-		}
+	}
 
 	netif_tx_start_all_queues(ndev);
 	return 0;
@@ -2575,17 +2333,17 @@ static int axienet_stop(struct net_device *ndev)
 
 	dev_dbg(&ndev->dev, "axienet_close()\n");
 
-	if (lp->axienet_config->mactype != XAXIENET_100G &&
-	    lp->axienet_config->mactype != XAXIENET_MRMAC_100G){
-
-		if (lp->phylink) {
-			phylink_stop(lp->phylink);
-			phylink_disconnect_phy(lp->phylink);
+	if (lp->axienet_config->mactype != XAXIENET_100G && lp->axienet_config->mactype != XAXIENET_MRMAC_100G){
+			if (lp->phylink) {
+				phylink_stop(lp->phylink);
+				phylink_disconnect_phy(lp->phylink);
 		}
 	}
-	if (lp->axienet_config->setoptions)
-		lp->axienet_config->setoptions(ndev, lp->options &
-				~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
+
+	if (lp->axienet_config->mactype != XAXIENET_100G &&
+	    lp->axienet_config->mactype != XAXIENET_MRMAC_100G)
+            lp->axienet_config->setoptions(ndev, lp->options &
+                                           ~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
 
 	for_each_tx_dma_queue(lp, i) {
 		q = lp->dq[i];
@@ -2596,11 +2354,9 @@ static int axienet_stop(struct net_device *ndev)
 		cr = axienet_dma_in32(q, XAXIDMA_TX_CR_OFFSET);
 		cr &= ~(XAXIDMA_CR_RUNSTOP_MASK | XAXIDMA_IRQ_ALL_MASK);
 		axienet_dma_out32(q, XAXIDMA_TX_CR_OFFSET, cr);
-		if (lp->axienet_config->mactype != XAXIENET_MRMAC_100G)
-			axienet_iow(lp, XAE_IE_OFFSET, 0);
 
-		if (lp->axienet_config->mactype == XAXIENET_1_2p5G)
-			axienet_iow(lp, XAE_IE_OFFSET, 0);
+			if (lp->axienet_config->mactype != XAXIENET_MRMAC_100G)
+				axienet_iow(lp, XAE_IE_OFFSET, 0);
 
 		/* Give DMAs a chance to halt gracefully */
 		sr = axienet_dma_in32(q, XAXIDMA_RX_SR_OFFSET);
@@ -2630,25 +2386,15 @@ static int axienet_stop(struct net_device *ndev)
 		free_irq(q->rx_irq, ndev);
 	}
 
-	if (lp->axienet_config->mactype == XAXIENET_1_2p5G && !lp->eth_hasnobuf)
+	if ((lp->axienet_config->mactype == XAXIENET_1G) && !(lp->eth_hasnobuf))
 		free_irq(lp->eth_irq, ndev);
 
-	if ((lp->axienet_config->mactype == XAXIENET_100G)
-			&lp->gpio_irq)
+	if ((lp->axienet_config->mactype == XAXIENET_100G) && (lp->gpio_irq))
 		free_irq(lp->gpio_irq, ndev);
 	axienet_dma_bd_release(ndev);
 
-	/* Delete the GRO Filter Rules when Reset is done */
-	if (lp->eoe_features & RX_HW_UDP_GRO && lp->rx_fs_list.count > 0) {
-		struct ethtool_rx_fs_item *item, *tmp;
-
-		list_for_each_entry_safe(item, tmp, &lp->rx_fs_list.list, list) {
-			lp->assigned_rx_port[item->fs.location] = 0;
-			list_del(&item->list);
-			lp->rx_fs_list.count--;
-			kfree(item);
-		}
-	}
+	if (lp->axienet_config->mactype == XAXIENET_1G_10G_25G)
+		cancel_delayed_work_sync(&lp->restart_work);
 
 	return 0;
 }
@@ -3154,6 +2900,24 @@ axienet_ethtools_get_link_ksettings(struct net_device *ndev,
 				    struct ethtool_link_ksettings *cmd)
 {
 	struct axienet_local *lp = netdev_priv(ndev);
+	int val;
+
+	if (lp->axienet_config->mactype == XAXIENET_1G_10G_25G) {
+		val = axienet_ior(lp, XXVS_SPEED_OFFSET);
+		if (val == XXVS_SPEED_1G) {
+			cmd->base.speed = SPEED_1000;
+			cmd->base.autoneg = axienet_ior(lp, XXVS_AN_CTL1_OFFSET) &
+							XXVS_AN_ENABLE_MASK;
+		} else if (val == XXVS_SPEED_10G) {
+			cmd->base.speed = SPEED_10000;
+			cmd->base.autoneg = axienet_ior(lp, XXVS_AN_CTL1_OFFSET) &
+							XXVS_AN_ENABLE_MASK;
+		} else {
+			cmd->base.speed = SPEED_UNKNOWN;
+		}
+
+		return 0;
+	}
 
 	if (!lp->phylink)
 		return -EOPNOTSUPP;
@@ -3167,6 +2931,17 @@ axienet_ethtools_set_link_ksettings(struct net_device *ndev,
 {
 	struct axienet_local *lp = netdev_priv(ndev);
 
+	if (lp->axienet_config->mactype == XAXIENET_1G_10G_25G) {
+		if (cmd->base.speed == SPEED_10000)
+			axienet_config_autoneg_link_training(lp, XXVS_AN_10G_ABILITY_MASK);
+		else if (cmd->base.speed == SPEED_1000)
+			axienet_config_autoneg_link_training(lp, XXVS_AN_1G_ABILITY_MASK);
+		else
+			netdev_err(ndev, "IP supports only 1G or 10G speed");
+
+		return 0;
+	}
+
 	if (!lp->phylink)
 		return -EOPNOTSUPP;
 
@@ -3238,7 +3013,7 @@ static int axienet_ethtools_get_ts_info(struct net_device *ndev,
  * Return: number of strings, on success, Non-zero error value on
  *	   failure.
  */
-static int axienet_ethtools_sset_count(struct net_device *ndev, int sset)
+int axienet_ethtools_sset_count(struct net_device *ndev, int sset)
 {
 	switch (sset) {
 	case ETH_SS_STATS:
@@ -3261,9 +3036,9 @@ static int axienet_ethtools_sset_count(struct net_device *ndev, int sset)
  *
  * Return: None.
  */
-static void axienet_ethtools_get_stats(struct net_device *ndev,
-				       struct ethtool_stats *stats,
-				       u64 *data)
+void axienet_ethtools_get_stats(struct net_device *ndev,
+				struct ethtool_stats *stats,
+				u64 *data)
 {
 	unsigned int i = 0;
 
@@ -3288,7 +3063,7 @@ static void axienet_ethtools_get_stats(struct net_device *ndev,
  *
  * Return: None.
  */
-static void axienet_ethtools_strings(struct net_device *ndev, u32 sset, u8 *data)
+void axienet_ethtools_strings(struct net_device *ndev, u32 sset, u8 *data)
 {
 	int i;
 
@@ -3303,65 +3078,6 @@ static void axienet_ethtools_strings(struct net_device *ndev, u32 sset, u8 *data
 #endif
 }
 
-#ifdef CONFIG_XILINX_AXI_EOE
-static int axienet_eoe_get_rxnfc(struct net_device *ndev, struct ethtool_rxnfc *cmd, u32 *rule_locs)
-{
-	struct axienet_local *lp = netdev_priv(ndev);
-	int ret = 0;
-
-	switch (cmd->cmd) {
-	case ETHTOOL_GRXRINGS:
-		cmd->data = lp->num_rx_queues;
-		break;
-	case ETHTOOL_GRXCLSRLCNT:
-		cmd->rule_cnt = lp->rx_fs_list.count;
-		break;
-	case ETHTOOL_GRXCLSRULE:
-		ret = axienet_eoe_get_flow_entry(ndev, cmd);
-		break;
-	case ETHTOOL_GRXCLSRLALL:
-		ret = axienet_eoe_get_all_flow_entries(ndev, cmd, rule_locs);
-		break;
-	default:
-		netdev_err(ndev, "Command parameter %d is not supported\n", cmd->cmd);
-		ret = -EOPNOTSUPP;
-	}
-
-	return ret;
-}
-
-static int axienet_eoe_set_rxnfc(struct net_device *ndev, struct ethtool_rxnfc *cmd)
-{
-	struct axienet_local *lp = netdev_priv(ndev);
-	int ret = -EOPNOTSUPP;
-
-	if (!(lp->eoe_features & RX_HW_UDP_GRO)) {
-		netdev_err(ndev, "HW GRO is not supported\n");
-		ret = -EINVAL;
-		return ret;
-	}
-
-	switch (cmd->cmd) {
-	case ETHTOOL_SRXCLSRLINS:
-		if (cmd->fs.location >= lp->num_rx_queues || cmd->fs.location == 0) {
-			netdev_err(ndev, "Invalid Location, 1 to 15 are valid GRO locations.");
-			ret = -EINVAL;
-			break;
-		}
-		ret = axienet_eoe_add_flow_filter(ndev, cmd);
-		break;
-	case ETHTOOL_SRXCLSRLDEL:
-		ret = axienet_eoe_del_flow_filter(ndev, cmd);
-		break;
-	default:
-		netdev_err(ndev, "Command parameter %d is not supported\n", cmd->cmd);
-		ret = -EOPNOTSUPP;
-	}
-
-	return ret;
-}
-#endif
-
 static const struct ethtool_ops axienet_ethtool_ops = {
 	.supported_coalesce_params = ETHTOOL_COALESCE_MAX_FRAMES |
 				     ETHTOOL_COALESCE_USECS,
@@ -3384,10 +3100,6 @@ static const struct ethtool_ops axienet_ethtool_ops = {
 	.get_link_ksettings = axienet_ethtools_get_link_ksettings,
 	.set_link_ksettings = axienet_ethtools_set_link_ksettings,
 	.nway_reset	= axienet_ethtools_nway_reset,
-#ifdef CONFIG_XILINX_AXI_EOE
-	.get_rxnfc = axienet_eoe_get_rxnfc,
-	.set_rxnfc = axienet_eoe_set_rxnfc,
-#endif
 };
 
 #ifdef CONFIG_AXIENET_HAS_MCDMA
@@ -3559,27 +3271,6 @@ static struct axienet_local *pcs_to_axienet_local(struct phylink_pcs *pcs)
 	return container_of(pcs, struct axienet_local, pcs);
 }
 
-static void axienet_dcmac_get_fixed_state(struct phylink_config *config,
-					  struct phylink_link_state *state)
-{
-	struct net_device *ndev = to_net_dev(config->dev);
-	struct axienet_local *lp = netdev_priv(ndev);
-	u32 rx_phy_stat;
-
-	state->duplex = DUPLEX_FULL;
-	state->speed = lp->max_speed;
-	state->an_complete = PHYLINK_PCS_NEG_NONE;
-
-	rx_phy_stat = axienet_ior(lp, DCMAC_STS_RX_PHY_OFFSET);
-	/* Clear previous status */
-	axienet_iow(lp, DCMAC_STS_RX_PHY_OFFSET, 0xFFFFFFFF);
-	rx_phy_stat = axienet_ior(lp, DCMAC_STS_RX_PHY_OFFSET);
-
-	state->link = (rx_phy_stat & DCMAC_RXPHY_RX_STS_MASK &&
-			rx_phy_stat & DCMAC_RXPHY_RX_ALIGN_MASK);
-	phylink_clear(state->advertising, Autoneg);
-}
-
 static void axienet_pcs_get_state(struct phylink_pcs *pcs,
 				  struct phylink_link_state *state)
 {
@@ -3587,7 +3278,12 @@ static void axienet_pcs_get_state(struct phylink_pcs *pcs,
 	u32 speed, an_status, val;
 	bool tx_pause, rx_pause;
 
-	if (lp->axienet_config->mactype == XAXIENET_10G_25G) {
+	if (lp->axienet_config->mactype != XAXIENET_10G_25G) {
+		struct mdio_device *pcs_phy = pcs_to_axienet_local(pcs)->pcs_phy;
+
+		phylink_mii_c22_pcs_get_state(pcs_phy, state);
+
+	} else {
 		int gt_rst, blk_lock;
 
 		speed = axienet_ior(lp, XXV_STAT_CORE_SPEED_OFFSET);
@@ -3616,31 +3312,6 @@ static void axienet_pcs_get_state(struct phylink_pcs *pcs,
 			if (!blk_lock)
 				state->link = 1;
 		}
-	} else if (lp->axienet_config->mactype == XAXIENET_1G_10G_25G) {
-		speed = axienet_ior(lp, XXVS_SPEED_OFFSET);
-		if (speed & XXVS_SPEED_1G)
-			state->speed = SPEED_1000;
-		else if (speed & XXVS_SPEED_10G)
-			state->speed = SPEED_10000;
-		else if (!(speed & ~XXVS_SPEED_25G))
-			state->speed = SPEED_25000;
-		else
-			state->speed = SPEED_UNKNOWN;
-
-		state->duplex = DUPLEX_FULL;
-		an_status = axienet_ior(lp, XXV_STAT_AN_STS_OFFSET);
-		tx_pause = an_status & XXV_TX_PAUSE_MASK;
-		rx_pause = an_status & XXV_RX_PAUSE_MASK;
-
-		state->pause = (tx_pause & MLO_PAUSE_TX) | (rx_pause & MLO_PAUSE_RX);
-		state->an_complete = an_status & XXV_AN_COMPLETE_MASK;
-
-		/* rx status bit indicates current status of link */
-		state->link = axienet_ior(lp, XXVS_RX_STATUS_REG1) & XXVS_RX_STATUS_MASK;
-	} else {
-		struct mdio_device *pcs_phy = pcs_to_axienet_local(pcs)->pcs_phy;
-
-		phylink_mii_c22_pcs_get_state(pcs_phy, state);
 	}
 }
 
@@ -3648,8 +3319,7 @@ static void axienet_pcs_an_restart(struct phylink_pcs *pcs)
 {
 	struct axienet_local *lp = pcs_to_axienet_local(pcs);
 
-	if (lp->axienet_config->mactype == XAXIENET_10G_25G ||
-	    lp->axienet_config->mactype == XAXIENET_1G_10G_25G) {
+	if (lp->axienet_config->mactype == XAXIENET_10G_25G) {
 		axienet_iow(lp, XXVS_AN_CTL1_OFFSET,
 			    (axienet_ior(lp, XXVS_AN_CTL1_OFFSET) |
 			     XXV_AN_RESTART_MASK));
@@ -3690,49 +3360,6 @@ static int axienet_pcs_config(struct phylink_pcs *pcs, unsigned int neg_mode,
 		/* If auto-negotiation is not completed, restart auto-neg */
 		return (neg_mode == (unsigned int)PHYLINK_PCS_NEG_INBAND_ENABLED &&
 			autoneg_complete == 0);
-	} else if (lp->axienet_config->mactype == XAXIENET_1G_10G_25G) {
-		bool an_enabled = false;
-
-		if (phylink_test(advertising, Autoneg))
-			an_enabled = true;
-
-		if (!an_enabled) {
-			/* Disable autoneg */
-			axienet_iow(lp, XXVS_AN_CTL1_OFFSET,
-				    (axienet_ior(lp, XXVS_AN_CTL1_OFFSET) &
-				    (~XXVS_AN_ENABLE_MASK | XXVS_AN_BYPASS)));
-			axienet_iow(lp, XXVS_RESET_OFFSET, XXVS_RX_SERDES_RESET);
-			axienet_iow(lp, XXVS_LT_CTL_OFFSET, 0);
-			axienet_iow(lp, XXVS_RESET_OFFSET, XXVS_RX_RESET | XXVS_TX_RESET);
-			axienet_iow(lp, XXVS_RESET_OFFSET, 0);
-		}
-
-		if (interface == PHY_INTERFACE_MODE_1000BASEX) {
-			if (an_enabled)
-				axienet_config_autoneg_link_training(lp, XXVS_AN_1G_ABILITY_MASK);
-			else
-				axienet_iow(lp, XXVS_TC_OFFSET, (axienet_ior(lp, XXVS_TC_OFFSET) &
-					    XXVS_CTRL_CORE_SPEED_SEL_CLEAR) |
-					    XXVS_CTRL_CORE_SPEED_SEL_1G);
-		} else if (interface == PHY_INTERFACE_MODE_10GBASER) {
-			if (an_enabled)
-				axienet_config_autoneg_link_training(lp, XXVS_AN_10G_ABILITY_MASK);
-			else
-				axienet_iow(lp, XXVS_TC_OFFSET, (axienet_ior(lp, XXVS_TC_OFFSET) &
-					    XXVS_CTRL_CORE_SPEED_SEL_CLEAR) |
-					    XXVS_CTRL_CORE_SPEED_SEL_10G);
-
-		} else if (interface == PHY_INTERFACE_MODE_25GBASER) {
-			if (an_enabled)
-				axienet_config_autoneg_link_training(lp, XXVS_AN_25G_ABILITY_MASK);
-			else
-				axienet_iow(lp, XXVS_TC_OFFSET, (axienet_ior(lp, XXVS_TC_OFFSET) &
-					     XXVS_CTRL_CORE_SPEED_SEL_CLEAR));
-		}
-		return 0;
-	} else if (lp->axienet_config->mactype == XAXIENET_DCMAC) {
-		/* Nothing to change for fixed link */
-		return 0;
 	}
 
 	ret = phylink_mii_c22_pcs_config(pcs_phy, interface, advertising,
@@ -3781,9 +3408,7 @@ static void axienet_mac_link_up(struct phylink_config *config,
 	struct axienet_local *lp = netdev_priv(ndev);
 	u32 emmc_reg, fcc_reg;
 
-	if (lp->axienet_config->mactype == XAXIENET_10G_25G ||
-	    lp->axienet_config->mactype == XAXIENET_1G_10G_25G ||
-	    lp->axienet_config->mactype == XAXIENET_DCMAC) {
+	if (lp->axienet_config->mactype == XAXIENET_10G_25G) {
 		/* nothing meaningful to do */
 		return;
 	}
@@ -3824,91 +3449,11 @@ static void axienet_mac_link_up(struct phylink_config *config,
 	axienet_iow(lp, XAE_FCC_OFFSET, fcc_reg);
 }
 
-static void axienet_mac_validate(struct phylink_config *config,
-				 unsigned long *supported,
-				 struct phylink_link_state *state)
-{
-	struct net_device *ndev = to_net_dev(config->dev);
-	struct axienet_local *lp = netdev_priv(ndev);
-	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
-	unsigned long supported_caps, adv_caps;
-
-	if (lp->axienet_config->mactype == XAXIENET_1G_10G_25G) {
-		/* Supported link mode */
-		phylink_set_port_modes(mask);
-		phylink_set(mask, Autoneg);
-		supported_caps = config->mac_capabilities;
-		phylink_caps_to_linkmodes(mask, supported_caps);
-		linkmode_and(supported, supported, mask);
-
-		/* Advertise link mode */
-		linkmode_zero(mask);
-		phylink_set_port_modes(mask);
-		if (phylink_test(state->advertising, Autoneg))
-			phylink_set(mask, Autoneg);
-		adv_caps =  MAC_SYM_PAUSE | MAC_ASYM_PAUSE;
-
-		switch (state->speed) {
-		case SPEED_1000:
-			adv_caps |= MAC_1000FD;
-			state->interface = PHY_INTERFACE_MODE_1000BASEX;
-			break;
-		case SPEED_10000:
-			adv_caps |= MAC_10000FD;
-			state->interface = PHY_INTERFACE_MODE_10GBASER;
-			break;
-		case SPEED_25000:
-			adv_caps |= MAC_25000FD;
-			state->interface = PHY_INTERFACE_MODE_25GBASER;
-			break;
-		default:
-			/* SPEED_UNKNOWN */
-			adv_caps = supported_caps;
-		}
-		phylink_caps_to_linkmodes(mask, adv_caps);
-
-		linkmode_and(state->advertising, supported, mask);
-	} else if (lp->axienet_config->mactype == XAXIENET_DCMAC) {
-		/* Supported link mode */
-		phylink_set_port_modes(mask);
-		supported_caps = config->mac_capabilities;
-		phylink_caps_to_linkmodes(mask, supported_caps);
-		linkmode_and(supported, supported, mask);
-
-		/* Advertise link mode */
-		linkmode_zero(mask);
-		phylink_set_port_modes(mask);
-		adv_caps =  MAC_SYM_PAUSE | MAC_ASYM_PAUSE;
-
-		switch (state->speed) {
-		case SPEED_100000:
-			adv_caps |= MAC_100000FD;
-			state->interface = PHY_INTERFACE_MODE_100GBASER;
-			break;
-		case SPEED_200000:
-			adv_caps |= MAC_200000FD;
-			state->interface = PHY_INTERFACE_MODE_200GBASER;
-			break;
-		case SPEED_400000:
-			adv_caps |= MAC_400000FD;
-			state->interface = PHY_INTERFACE_MODE_400GBASER;
-			break;
-		default:
-			/* SPEED_UNKNOWN */
-			adv_caps = supported_caps;
-		}
-		phylink_caps_to_linkmodes(mask, adv_caps);
-
-		linkmode_and(state->advertising, supported, mask);
-	}
-}
-
 static const struct phylink_mac_ops axienet_phylink_ops = {
 	.mac_select_pcs = axienet_mac_select_pcs,
 	.mac_config = axienet_mac_config,
 	.mac_link_down = axienet_mac_link_down,
 	.mac_link_up = axienet_mac_link_up,
-	.validate = axienet_mac_validate,
 };
 
 static int axienet_clk_init(struct platform_device *pdev,
@@ -4156,8 +3701,15 @@ static int xxvenet_clk_init(struct platform_device *pdev,
 	return err;
 }
 
-static const struct axienet_config axienet_1_2p5g_config = {
-	.mactype = XAXIENET_1_2p5G,
+static const struct axienet_config axienet_1g_config = {
+	.mactype = XAXIENET_1G,
+	.setoptions = axienet_setoptions,
+	.clk_init = axienet_clk_init,
+	.tx_ptplen = XAE_TX_PTP_LEN,
+};
+
+static const struct axienet_config axienet_2_5g_config = {
+	.mactype = XAXIENET_2_5G,
 	.setoptions = axienet_setoptions,
 	.clk_init = axienet_clk_init,
 	.tx_ptplen = XAE_TX_PTP_LEN,
@@ -4176,7 +3728,6 @@ static const struct axienet_config axienet_10g25g_config = {
 	.clk_init = xxvenet_clk_init,
 	.tx_ptplen = XXV_TX_PTP_LEN,
 	.ts_header_len = XXVENET_TS_HEADER_LEN,
-	.gt_reset = xxv_gt_reset,
 };
 
 static const struct axienet_config axienet_1g10g25g_config = {
@@ -4184,7 +3735,6 @@ static const struct axienet_config axienet_1g10g25g_config = {
 	.setoptions = xxvenet_setoptions,
 	.clk_init = xxvenet_clk_init,
 	.tx_ptplen = XXV_TX_PTP_LEN,
-	.gt_reset = xxv_gt_reset,
 };
 
 static const struct axienet_config axienet_usxgmii_config = {
@@ -4200,7 +3750,6 @@ static const struct axienet_config axienet_mrmac_config = {
 	.clk_init = xxvenet_clk_init,
 	.tx_ptplen = XXV_TX_PTP_LEN,
 	.ts_header_len = MRMAC_TS_HEADER_LEN,
-	.gt_reset = axienet_mrmac_gt_reset,
 };
 
 static const struct axienet_config cmac_100g_config = {
@@ -4210,19 +3759,20 @@ static const struct axienet_config cmac_100g_config = {
 	.tx_ptplen = 0,
 };
 
-static const struct axienet_config axienet_dcmac_config = {
-	.mactype = XAXIENET_DCMAC,
+static const struct axienet_config mrmac_100g_config = {
+	.mactype = XAXIENET_MRMAC_100G,
+	.setoptions = NULL,
 	.clk_init = xxvenet_clk_init,
-	.gt_reset = dcmac_gt_reset,
+	.tx_ptplen = 0,
 };
 
 /* Match table for of_platform binding */
 static const struct of_device_id axienet_of_match[] = {
-	{ .compatible = "xlnx,axi-ethernet-1.00.a", .data = &axienet_1_2p5g_config},
-	{ .compatible = "xlnx,axi-ethernet-1.01.a", .data = &axienet_1_2p5g_config},
-	{ .compatible = "xlnx,axi-ethernet-2.01.a", .data = &axienet_1_2p5g_config},
+	{ .compatible = "xlnx,axi-ethernet-1.00.a", .data = &axienet_1g_config},
+	{ .compatible = "xlnx,axi-ethernet-1.01.a", .data = &axienet_1g_config},
+	{ .compatible = "xlnx,axi-ethernet-2.01.a", .data = &axienet_1g_config},
 	{ .compatible = "xlnx,axi-2_5-gig-ethernet-1.0",
-						.data = &axienet_1_2p5g_config},
+						.data = &axienet_2_5g_config},
 	{ .compatible = "xlnx,ten-gig-eth-mac", .data = &axienet_10g_config},
 	{ .compatible = "xlnx,xxv-ethernet-1.0",
 						.data = &axienet_10g25g_config},
@@ -4241,56 +3791,11 @@ static const struct of_device_id axienet_of_match[] = {
 					.data = &cmac_100g_config},
 	{ .compatible = "xlnx,ethernet-1-10-25g-2.7",
 					.data = &axienet_1g10g25g_config},
-	{ .compatible = "xlnx,dcmac-2.4",
-					.data = &axienet_dcmac_config},
 	{},
 };
 
 MODULE_DEVICE_TABLE(of, axienet_of_match);
 
-static int axienet_eoe_netdev_event(struct notifier_block *this, unsigned long event,
-				    void *ptr)
-{
-	struct axienet_local *lp = container_of(this, struct axienet_local,
-						inetaddr_notifier);
-	struct in_ifaddr *ifa = ptr;
-	struct axienet_dma_q *q;
-	int i;
-
-	struct net_device *ndev = ifa->ifa_dev->dev;
-
-	if (lp->ndev != ndev) {
-		dev_err(lp->dev, " ndev is not matched to configure GRO IP address\n");
-	} else {
-		switch (event) {
-		case NETDEV_UP:
-			dev_dbg(lp->dev, "%s:NETDEV_UP\n", __func__);
-			for_each_rx_dma_queue(lp, i) {
-				q = lp->dq[i];
-				if (axienet_eoe_is_channel_gro(lp, q))
-					axienet_eoe_iow(lp,
-							XEOE_UDP_GRO_DST_IP_OFFSET(q->chan_id),
-							ntohl(ifa->ifa_address));
-			}
-		break;
-		case NETDEV_DOWN:
-			dev_dbg(lp->dev, "%s:NETDEV_DOWN\n", __func__);
-			for_each_rx_dma_queue(lp, i) {
-				q = lp->dq[i];
-				if (axienet_eoe_is_channel_gro(lp, q))
-					axienet_eoe_iow(lp,
-							XEOE_UDP_GRO_DST_IP_OFFSET(q->chan_id),
-							0);
-			}
-		break;
-		default:
-			dev_err(lp->dev, "IPv4 Ethernet address is not set\n");
-		}
-	}
-
-	return NOTIFY_DONE;
-}
-
 /**
  * axienet_probe - Axi Ethernet probe function.
  * @pdev:	Pointer to platform device structure.
@@ -4354,8 +3859,6 @@ static int axienet_probe(struct platform_device *pdev)
 	lp->rx_bd_num = RX_BD_NUM_DEFAULT;
 	lp->tx_bd_num = TX_BD_NUM_DEFAULT;
 
-	INIT_LIST_HEAD(&lp->rx_fs_list.list);
-
 	lp->axi_clk = devm_clk_get_optional(&pdev->dev, "s_axi_lite_clk");
 	if (!lp->axi_clk) {
 		/* For backward compatibility, if named AXI clock is not present,
@@ -4459,8 +3962,10 @@ static int axienet_probe(struct platform_device *pdev)
 	lp->switch_x_sgmii = of_property_read_bool(pdev->dev.of_node,
 						   "xlnx,switch-x-sgmii");
 
+	lp->phy_mode = PHY_INTERFACE_MODE_NA;
 	/* Start with the proprietary, and broken phy_type */
-	if (lp->axienet_config->mactype != XAXIENET_MRMAC) {
+	if (lp->axienet_config->mactype != XAXIENET_1G_10G_25G &&
+	    lp->axienet_config->mactype != XAXIENET_MRMAC) {
 		ret = of_property_read_u32(pdev->dev.of_node, "xlnx,phy-type", &value);
 		if (!ret) {
 			switch (value) {
@@ -4488,44 +3993,35 @@ static int axienet_probe(struct platform_device *pdev)
 			}
 		} else {
 			ret = of_get_phy_mode(pdev->dev.of_node, &lp->phy_mode);
-			if (ret)
-				goto cleanup_clk;
+			/* if (ret) */
+                        /* { */
+			/* 	goto cleanup_clk; */
+                        /* } */
 		}
 	}
+	if (lp->switch_x_sgmii && lp->phy_mode != PHY_INTERFACE_MODE_SGMII &&
+	    lp->phy_mode != PHY_INTERFACE_MODE_1000BASEX) {
+		dev_err(&pdev->dev, "xlnx,switch-x-sgmii only supported with SGMII or 1000BaseX\n");
+		ret = -EINVAL;
+		goto cleanup_clk;
+	}
 
 	/* Set default USXGMII rate */
 	lp->usxgmii_rate = SPEED_1000;
 	of_property_read_u32(pdev->dev.of_node, "xlnx,usxgmii-rate",
 			     &lp->usxgmii_rate);
 
-	if (lp->axienet_config->mactype == XAXIENET_1_2p5G ||
-	    lp->axienet_config->mactype == XAXIENET_MRMAC ||
-	    lp->axienet_config->mactype == XAXIENET_DCMAC) {
-		ret = of_property_read_u32(pdev->dev.of_node, "max-speed",
-					   &lp->max_speed);
-
-		if (ret && lp->axienet_config->mactype == XAXIENET_MRMAC) {
-			ret = of_property_read_u32(pdev->dev.of_node,
-						   "xlnx,mrmac-rate",
-						   &lp->max_speed);
-			if (!ret) {
-				dev_warn(&pdev->dev,
-					 "xlnx,mrmac-rate is deprecated, please use max-speed instead\n");
-			}
-		}
-		if (ret) {
-			dev_err(&pdev->dev, "couldn't find MAC Rate\n");
-			goto cleanup_clk;
-		}
-	}
+	/* Set default MRMAC rate */
+	lp->mrmac_rate = SPEED_10000;
+	of_property_read_u32(pdev->dev.of_node, "xlnx,mrmac-rate",
+			     &lp->mrmac_rate);
 
 	lp->eth_hasnobuf = of_property_read_bool(pdev->dev.of_node,
 						 "xlnx,eth-hasnobuf");
 	lp->eth_hasptp = of_property_read_bool(pdev->dev.of_node,
 					       "xlnx,eth-hasptp");
 
-	if (lp->axienet_config->mactype == XAXIENET_1_2p5G &&
-	    !lp->eth_hasnobuf)
+	if (lp->axienet_config->mactype == XAXIENET_1G && !lp->eth_hasnobuf)
 		lp->eth_irq = platform_get_irq(pdev, 0);
 
 	if (lp->axienet_config->mactype == XAXIENET_MRMAC ||
@@ -4542,7 +4038,7 @@ static int axienet_probe(struct platform_device *pdev)
 				dev_err(&pdev->dev,
 					"couldn't find GT PLL\n");
 				ret = PTR_ERR(np);
-				goto cleanup_clk;
+ 				goto cleanup_clk;
 			}
 
 			ret = of_address_to_resource(np, 0, &gtpll);
@@ -4603,66 +4099,6 @@ static int axienet_probe(struct platform_device *pdev)
 			goto cleanup_clk;
 		}
 		dev_info(&pdev->dev, "GT lane: %d\n", lp->gt_lane);
-	} else if (lp->axienet_config->mactype == XAXIENET_DCMAC) {
-		lp->gds_gt_ctrl = devm_gpiod_get_array(&pdev->dev,
-						       "gt_ctrl",
-						       GPIOD_OUT_LOW);
-		if (IS_ERR(lp->gds_gt_ctrl)) {
-			dev_err(&pdev->dev,
-				"Failed to request GT control GPIO\n");
-			ret = PTR_ERR(lp->gds_gt_ctrl);
-			goto cleanup_clk;
-		}
-
-		lp->gds_gt_rx_dpath = devm_gpiod_get_array(&pdev->dev,
-							   "gt_rx_dpath",
-							    GPIOD_OUT_LOW);
-		if (IS_ERR(lp->gds_gt_rx_dpath)) {
-			dev_err(&pdev->dev,
-				"Failed to request GT Rx dpath GPIO\n");
-			ret = PTR_ERR(lp->gds_gt_rx_dpath);
-			goto cleanup_clk;
-		}
-
-		lp->gds_gt_tx_dpath = devm_gpiod_get_array(&pdev->dev,
-							   "gt_tx_dpath",
-							   GPIOD_OUT_LOW);
-		if (IS_ERR(lp->gds_gt_tx_dpath)) {
-			dev_err(&pdev->dev,
-				"Failed to request GT Tx dpath GPIO\n");
-			ret = PTR_ERR(lp->gds_gt_tx_dpath);
-			goto cleanup_clk;
-		}
-
-		lp->gds_gt_rsts = devm_gpiod_get_array(&pdev->dev,
-						       "gt_rsts",
-						       GPIOD_OUT_LOW);
-		if (IS_ERR(lp->gds_gt_rsts)) {
-			dev_err(&pdev->dev,
-				"Failed to request GT Resets GPIO\n");
-			ret = PTR_ERR(lp->gds_gt_rsts);
-			goto cleanup_clk;
-		}
-
-		lp->gds_gt_tx_reset_done =  devm_gpiod_get_array(&pdev->dev,
-								 "gt_tx_rst_done",
-								 GPIOD_IN);
-		if (IS_ERR(lp->gds_gt_tx_reset_done)) {
-			dev_err(&pdev->dev,
-				"Failed to request GT Tx Reset Done GPIO\n");
-			ret = PTR_ERR(lp->gds_gt_tx_reset_done);
-			goto cleanup_clk;
-		}
-
-		lp->gds_gt_rx_reset_done =  devm_gpiod_get_array(&pdev->dev,
-								 "gt_rx_rst_done",
-								 GPIOD_IN);
-		if (IS_ERR(lp->gds_gt_rx_reset_done)) {
-			dev_err(&pdev->dev,
-				"Failed to request GT Rx Reset Done GPIO\n");
-			ret = PTR_ERR(lp->gds_gt_rx_reset_done);
-			goto cleanup_clk;
-		}
 	}
 
 #ifdef CONFIG_XILINX_AXI_EMAC_HWTSTAMP
@@ -4725,17 +4161,6 @@ static int axienet_probe(struct platform_device *pdev)
 	    lp->axienet_config->mactype == XAXIENET_1G_10G_25G)
 		lp->xxv_ip_version = axienet_ior(lp, XXV_CONFIG_REVISION);
 
-	lp->eoe_connected = of_property_read_bool(pdev->dev.of_node,
-						  "xlnx,has-hw-offload");
-
-	if (lp->eoe_connected) {
-		ret = axienet_eoe_probe(pdev);
-		if (ret) {
-			dev_err(&pdev->dev, "Ethernet Offload not Supported\n");
-			goto cleanup_clk;
-		}
-	}
-
 #ifdef CONFIG_AXIENET_HAS_MCDMA
 	ret = axienet_mcdma_probe(pdev, lp, ndev);
 #else
@@ -4792,7 +4217,7 @@ static int axienet_probe(struct platform_device *pdev)
 	if (lp->axienet_config->mactype != XAXIENET_10G_25G &&
 	    lp->axienet_config->mactype != XAXIENET_1G_10G_25G &&
 	    lp->axienet_config->mactype != XAXIENET_MRMAC &&
-	    lp->axienet_config->mactype != XAXIENET_DCMAC) {
+            lp->axienet_config->mactype != XAXIENET_MRMAC_100G) {
 		np = of_parse_phandle(pdev->dev.of_node, "pcs-handle", 0);
 		if (!np) {
 			/* For SGMII/1000BaseX:
@@ -4825,7 +4250,9 @@ static int axienet_probe(struct platform_device *pdev)
 		of_node_put(np);
 	}
 
-	if (lp->axienet_config->mactype != XAXIENET_MRMAC) {
+	if (lp->axienet_config->mactype != XAXIENET_1G_10G_25G &&
+	    lp->axienet_config->mactype != XAXIENET_MRMAC &&
+            lp->axienet_config->mactype != XAXIENET_MRMAC_100G) {
 		lp->pcs.ops = &axienet_pcs_ops;
 		lp->pcs.neg_mode = true;
 		lp->pcs.poll = true;
@@ -4851,76 +4278,34 @@ static int axienet_probe(struct platform_device *pdev)
 					lp->phylink_config.mac_capabilities |= MAC_25000FD;
 				}
 			}
-		} else if (lp->axienet_config->mactype == XAXIENET_1G_10G_25G) {
-			const char *rt_switch;
-
-			of_property_read_string(pdev->dev.of_node,
-						"xlnx,runtime-switch",
-						 &rt_switch);
-
-			/* 1G/10G switching by default */
-			lp->phylink_config.mac_capabilities |= (MAC_1000FD |
-									MAC_10000FD);
-			__set_bit(PHY_INTERFACE_MODE_1000BASEX,
-				  lp->phylink_config.supported_interfaces);
-			__set_bit(PHY_INTERFACE_MODE_10GBASER,
-				  lp->phylink_config.supported_interfaces);
-
-			if (!strcmp(rt_switch, (const char *)XXVS_RT_SWITCH_1G_10G_25G)) {
-				lp->phylink_config.mac_capabilities |= MAC_25000FD;
-
-				__set_bit(PHY_INTERFACE_MODE_25GBASER,
-					  lp->phylink_config.supported_interfaces);
-			}
-		} else if (lp->axienet_config->mactype == XAXIENET_DCMAC) {
-			if (lp->max_speed == SPEED_100000) {
-				lp->phylink_config.mac_capabilities |= MAC_100000FD;
-				__set_bit(PHY_INTERFACE_MODE_100GBASER,
-					  lp->phylink_config.supported_interfaces);
-			} else if (lp->max_speed == SPEED_200000) {
-				lp->phylink_config.mac_capabilities |= MAC_200000FD;
-				__set_bit(PHY_INTERFACE_MODE_200GBASER,
-					  lp->phylink_config.supported_interfaces);
-			} else if (lp->max_speed == SPEED_400000) {
-				lp->phylink_config.mac_capabilities |= MAC_400000FD;
-				__set_bit(PHY_INTERFACE_MODE_400GBASER,
-					  lp->phylink_config.supported_interfaces);
-			}
-
-			lp->phylink_config.get_fixed_state = axienet_dcmac_get_fixed_state;
 		} else {
-			/* AXI 1G/2.5G */
-			if (lp->max_speed == SPEED_1000) {
-				lp->phylink_config.mac_capabilities = (MAC_10FD | MAC_100FD |
-								       MAC_1000FD);
-				if (lp->switch_x_sgmii)
-					__set_bit(PHY_INTERFACE_MODE_SGMII |
-						  PHY_INTERFACE_MODE_1000BASEX,
-						  lp->phylink_config.supported_interfaces);
-
-			} else {
-				/* 2.5G speed */
-				lp->phylink_config.mac_capabilities |= MAC_2500FD;
-				if (lp->switch_x_sgmii)
-					__set_bit(PHY_INTERFACE_MODE_SGMII |
-						  PHY_INTERFACE_MODE_1000BASEX,
-						  lp->phylink_config.supported_interfaces);
-			}
+			lp->phylink_config.mac_capabilities = (MAC_10FD | MAC_100FD |
+							       MAC_1000FD);
 		}
 	}
-
-	__set_bit(lp->phy_mode, lp->phylink_config.supported_interfaces);
-
-	if (lp->axienet_config->mactype != XAXIENET_MRMAC) {
+        if(lp->axienet_config->mactype != XAXIENET_MRMAC_100G)
+        {
+            __set_bit(lp->phy_mode, lp->phylink_config.supported_interfaces);
+            if (lp->switch_x_sgmii) {
+		__set_bit(PHY_INTERFACE_MODE_1000BASEX,
+			  lp->phylink_config.supported_interfaces);
+		__set_bit(PHY_INTERFACE_MODE_SGMII,
+			  lp->phylink_config.supported_interfaces);
+            }
+
+            if (lp->axienet_config->mactype != XAXIENET_1G_10G_25G &&
+                lp->axienet_config->mactype != XAXIENET_MRMAC) {
 		lp->phylink = phylink_create(&lp->phylink_config, pdev->dev.fwnode,
 					     lp->phy_mode,
 					     &axienet_phylink_ops);
-	}
-	if (IS_ERR(lp->phylink)) {
+            }
+            if (IS_ERR(lp->phylink)) {
 		ret = PTR_ERR(lp->phylink);
 		dev_err(&pdev->dev, "phylink_create error (%i)\n", ret);
+
 		goto cleanup_mdio;
-	}
+            }
+        }
 
 #ifdef CONFIG_AXIENET_HAS_MCDMA
 	/* Create sysfs file entries for the device */
@@ -4931,48 +4316,20 @@ static int axienet_probe(struct platform_device *pdev)
 	}
 #endif
 
-	/* Set the TX coalesce count to 1. With offload enabled, there are not as
-	 * many interrupts as before and the interrupt for every 64KB segment needs
-	 * to be handled immediately to ensure better performance.
-	 */
-	if (ndev->hw_features & NETIF_F_GSO_UDP_L4)
-		lp->coalesce_count_tx = XMCDMA_DFT_TX_THRESHOLD;
-
-	/* Update the required thresholds for Rx HW UDP GRO
-	 * GRO receives 16 segmented data packets from MAC
-	 * and packet coalescing increases performance.
-	 */
-	if (lp->eoe_features & RX_HW_UDP_GRO)
-		lp->coalesce_count_rx = XMCDMA_DFT_RX_THRESHOLD;
-
 	ret = register_netdev(lp->ndev);
 	if (ret) {
 		dev_err(lp->dev, "register_netdev() error (%i)\n", ret);
 		goto cleanup_phylink;
 	}
 
-	/* Register notifier for inet address additions/deletions.
-	 * It should be called after register_netdev to access the interface's
-	 * network configuration parameters.
-	 */
-
 	if (lp->axienet_config->mactype == XAXIENET_100G)
 		axienet_100G_link_sts(pdev, ndev);
 
-	if (lp->eoe_features & RX_HW_UDP_GRO) {
-		lp->inetaddr_notifier.notifier_call = axienet_eoe_netdev_event;
-		ret = register_inetaddr_notifier(&lp->inetaddr_notifier);
-		if (ret) {
-			dev_err(lp->dev, "register_netdevice_notifier() error\n");
-			goto err_unregister_netdev;
-		}
-	}
+	if (lp->axienet_config->mactype == XAXIENET_1G_10G_25G)
+		INIT_DELAYED_WORK(&lp->restart_work, speed_monitor_thread);
 
 	return 0;
 
-err_unregister_netdev:
-	unregister_netdev(ndev);
-
 cleanup_phylink:
 	phylink_destroy(lp->phylink);
 
@@ -5002,8 +4359,6 @@ static int axienet_remove(struct platform_device *pdev)
 
 	for_each_rx_dma_queue(lp, i)
 		netif_napi_del(&lp->napi[i]);
-	if (lp->eoe_features & RX_HW_UDP_GRO)
-		unregister_inetaddr_notifier(&lp->inetaddr_notifier);
 	unregister_netdev(ndev);
 	axienet_clk_disable(pdev);
 
