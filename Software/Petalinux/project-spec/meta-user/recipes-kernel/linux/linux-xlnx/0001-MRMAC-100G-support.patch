diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet.h b/drivers/net/ethernet/xilinx/xilinx_axienet.h
old mode 100644
new mode 100755
index 834b05beaafe..857e54643355
--- a/drivers/net/ethernet/xilinx/xilinx_axienet.h
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet.h
@@ -577,6 +577,7 @@
 #define MRMAC_CONFIG_RX_OFFSET		0x00000010
 #define MRMAC_TICK_OFFSET		0x0000002C
 #define MRMAC_CFG1588_OFFSET	0x00000040
+#define MRMAC_FEC_CONFIG_REG1_OFFSET	0x000000D0
 
 /* Status Registers */
 #define MRMAC_TX_STS_OFFSET		0x00000740
@@ -604,7 +605,8 @@
 #define MRMAC_RX_BLKLCK_MASK		BIT(0)
 #define MRMAC_RX_STATUS_MASK		BIT(0)
 #define MRMAC_RX_VALID_MASK		BIT(0)
-
+#define MRMAC_RX_100G_BLKLCK_MASK	0xFFFFF
+#define MRMAC_RX_ALIGN_MASK		(BIT(16) | BIT(2) | BIT(1) | BIT(0))
 #define MRMAC_CTL_DATA_RATE_MASK	GENMASK(2, 0)
 #define MRMAC_CTL_DATA_RATE_10G		0
 #define MRMAC_CTL_DATA_RATE_25G		1
@@ -616,11 +618,13 @@
 #define MRMAC_CTL_AXIS_CFG_SHIFT	9
 #define MRMAC_CTL_AXIS_CFG_10G_IND	1
 #define MRMAC_CTL_AXIS_CFG_25G_IND	1
+#define MRMAC_CTL_AXIS_CFG_100G_IND	5
 
 #define MRMAC_CTL_SERDES_WIDTH_MASK	GENMASK(6, 4)
 #define MRMAC_CTL_SERDES_WIDTH_SHIFT	4
 #define MRMAC_CTL_SERDES_WIDTH_10G	4
 #define MRMAC_CTL_SERDES_WIDTH_25G	6
+#define MRMAC_CTL_SERDES_WIDTH_100G	6
 
 #define MRMAC_CTL_RATE_CFG_MASK		(MRMAC_CTL_DATA_RATE_MASK |	\
 					 MRMAC_CTL_AXIS_CFG_MASK |	\
@@ -630,6 +634,8 @@
 #define MRMAC_TICK_TRIGGER		BIT(0)
 #define MRMAC_ONE_STEP_EN		BIT(0)
 
+#define MRMAC_RSFEC_OP_MODE		0x8
+#define MRMAC_RSFEC_TX_FOUR_LANE_PMD	BIT(12)
 /* MRMAC GT wrapper registers */
 #define MRMAC_GT_PLL_OFFSET		0x0
 #define MRMAC_GT_PLL_STS_OFFSET		0x8
@@ -637,6 +643,7 @@
 #define MRMAC_GT_CTRL_OFFSET		0x8
 
 #define MRMAC_GT_PLL_RST_MASK		0x00030003
+#define MRMAC_GT_LOCK_MASK		0xF
 #define MRMAC_GT_PLL_DONE_MASK		0xFF
 #define MRMAC_GT_RST_ALL_MASK		BIT(0)
 #define MRMAC_GT_RST_RX_MASK		BIT(1)
@@ -647,6 +654,34 @@
 #define MRMAC_GT_LANE_OFFSET		BIT(16)
 #define MRMAC_MAX_GT_LANES		4
 
+#define MRMAC_GT_100G_RST_VALUE		0xF02
+#define	MRMAC_GT_100G_LINE_RATE		0x2
+
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG1      0x0000004C
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG1_VAL  0xFFFFFFFF
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG2      0x00000050
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG2_VAL  0xFFFFFFFF
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG3      0x00000054
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG3_VAL  0xFFFFFFFF
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG4      0x00000058
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG4_VAL  0xFFFFFFFF
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG5      0x0000005C
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG5_VAL  0x0000FFFF
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG1       0x00000060
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG1_VAL   0xFFFFFFFF
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG2       0x00000064
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG2_VAL   0xFFFFFFFF
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG3       0x00000068
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG3_VAL   0xFFFFFFFF
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG4       0x0000006C
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG4_VAL   0xFFFFFFFF
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG5       0x00000070
+#define MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG5_VAL   0x0000FFFF
+
+#define MRMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG1      0x0000009C
+#define MRMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG1_VAL  0x0000004F
+#define MRMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG2      0x000000A0
+#define MRMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG2_VAL  0x00084210
 /* DCMAC Register Definitions */
 /* Global registers */
 #define DCMAC_G_MODE_OFFSET		0x00000004
@@ -811,6 +846,15 @@ struct aximcdma_bd {
 #else
 #define XAE_MAX_QUEUES		1
 #endif
+/*CMAC 100G AXI-GPIO interrupt for link status notification*/
+#define GPIO_CHN1_DATA_REG	0x0
+#define GPIO_CHN1_TRI_REG	0x4
+#define GPIO_GLOBAL_INT_EN_REG	0x11c
+#define GPIO_INT_EN_REG		0x128
+#define GPIO_INT_STS_REG	0x120
+#define GPIO_INT_CHN1_MASK	BIT(0)
+#define GPIO_GLOBAL_INT_MASK	BIT(31)
+#define AXI_GPIO_INT		"axigpio"
 
 struct ethtool_rx_fs_list {
 	struct list_head list;
@@ -1071,6 +1115,249 @@ struct axienet_dma_q {
 #define AXIENET_TX_SSTATS_LEN(lp) ((lp)->num_tx_queues * 2)
 #define AXIENET_RX_SSTATS_LEN(lp) ((lp)->num_rx_queues * 2)
 
+#define XCMAC_CONFIG_REG_BASE            0x00000000
+
+/* Register offset wrt the XMAC_CONFIG_REG_BASE */
+#define XCMAC_GT_RESET_REG_OFFSET              0x00000000 /** GT Reset Rgister */
+#define XCMAC_GT_RESET_ALL_MASK                0x00000001 /** Bit[0] will issue a reset to the GT. This bit is clear on write */
+
+#define XCMAC_RESET_REG_OFFSET                 0x00000004 /** Reset Register */
+#define XCMAC_TX_CORE_RESET_MASK               0x80000000 /** Bit[31] will issue a reset to the TX core */
+#define XCMAC_RX_CORE_RESET_MASK               0x40000000 /** Bit [30] will issue a reset to the RX core */
+#define XCMAC_OUT_OF_RESET                     0x00000000
+
+#define XCMAC_MODE_REG_OFFSET                  0x00000008 /** Mode register. Bit[0] when set to 1 puts the 100GE PCS in CAU14 mode, when set to 0 puts the 100GE PCS in CAU10 mode */
+
+#define XCMAC_CONFIG_TX_REG1_OFFSET            0x0000000C /** Configuration TX register 1 */
+#define XCMAC_CONFIG_TX_REG1_ENABLE_MASK       0x00000001
+#define XCMAC_CONFIG_TX_REG1_SEND_RFI_MASK     0x00000010
+#define XCMAC_CONFIG_TX_REG1_SEND_IDLE_MASK    0x00000020
+#define XCMAC_CONFIG_TX_REG1_TEST_PATTER_MASK  0x00010000
+
+//0x0010       Reserved
+
+#define XCMAC_CONFIG_RX_REG1_OFFSET            0x00000014 /** Configuration RX register 1 */
+#define XCMAC_CONFIG_RX_REG1_ENABLE_MASK       0x00000001
+#define XCMAC_CONFIG_RX_REG1_FORCE_RESYNC_MASK 0x00000080
+#define XCMAC_CONFIG_RX_REG1_TEST_PATTERN_MASK 0X00000100
+
+//0x001C - 0x0020        Reserved
+
+//moved in the 16.1
+#define XCMAC_CORE_VERSION_REG_OFFSET          0x00000024 /** Core version register */
+#define XCMAC_CORE_VERSION_REG_MINOR_MASK      0x000000FF
+#define XCMAC_CORE_VERSION_REG_MAJOR_MASK      0x0000FF00
+
+//0x0028        Reserved
+#define XCMAC_CONFIG_TX_BIP_OVERRIDE                   0x0000002C /** Value to override the bip7 byte of the PCS lane 0. */
+#define XCMAC_CONFIG_TX_BIP_OVERRIDE_LANE0_VLM_BIP7_OVERRIDE MASK 0x00000010
+
+/* RX Flow control control REG1 value as per PG - Core Bring Up Sequence. */
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_CONTROL_REG1      0x00000030 /** The flow control register enables the orrsponding signals to the pause and priority pause frames reception. */
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_CONTROL_REG1_VAL  0x000001FF
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG1      0x00000034
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG1_VAL  0xFFFFFFFF
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG2      0x00000038
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG2_VAL  0xFFFFFFFF
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG3      0x0000003C
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG3_VAL  0xFFFFFFFF
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG4      0x00000040
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG4_VAL  0xFFFFFFFF
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG5      0x00000044
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG5_VAL  0x0000FFFF
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG1       0x00000048
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG1_VAL   0xFFFFFFFF
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG2       0x0000004C
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG2_VAL   0xFFFFFFFF
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG3       0x00000050
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG3_VAL   0xFFFFFFFF
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG4       0x00000054
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG4_VAL   0xFFFFFFFF
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG5       0x00000058
+#define XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG5_VAL   0x0000FFFF
+//0x005C - 0x0080      Reserved
+
+#define XCMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG1      0x00000084 /** RX Flow control control register 1. */
+#define XCMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG1_VAL  0x00003DFF
+#define XCMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG2      0x00000088 /** RX Flow control control register 2.*/
+#define XCMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG2_VAL  0x0001C631
+//0x008C - 0x01FF      Reserved
+
+/* Status and Statistics Register Map */
+#define XCMAC_STAT_TX_STATUS_REG_OFFSET                0x00000200 /** TX Status register */
+#define XCMAC_STAT_RX_STATUS_REG_OFFSET                0x00000204 /** RX Status register */
+#define XCMAC_STAT_RX_STATUS_REG_STATUS_MASK           0x00000001
+#define XCMAC_STAT_RX_STATUS_REG_ALIGNED_MASK          0x00000002
+#define XCMAC_STAT_RX_STATUS_REG_MIS_ALIGNED_MASK      0x00000004
+#define XCMAC_STAT_RX_STATUS_REG_ALIGNED_ERR_MASK      0x00000008
+#define XCMAC_STAT_RX_STATUS_REG_HI_BER_MASK           0x00000010
+#define XCMAC_STAT_RX_STATUS_REG_REMOTE_FAULT_MASK     0x00000020
+#define XCMAC_STAT_RX_STATUS_REG_LOCAL_FAULT_MASK      0x00000040
+#define XCMAC_STAT_RX_STATUS_REG_INTERNAL_LOCAL_FAULT_MASK   0x00000080
+#define XCMAC_STAT_RX_STATUS_REG_RECEIVED_LOCAL_FAULT_MASK   0x00000100
+#define XCMAC_STAT_RX_STATUS_REG_TEST_PATTERN_MISMATCH_MASK  0x00000E00
+#define XCMAC_STAT_RX_STATUS_REG_BAD_PREAMBLE_MASK     0x00001000
+#define XCMAC_STAT_RX_STATUS_REG_BAD_SFD_MASK          0x00002000
+#define XCMAC_STAT_RX_STATUS_REG_GOT_SIGNAL_OS_MASK    0x00004000
+
+#define XCMAC_STAT_STATUS_REG1                0x00000208 /** Status register */
+
+#define XCMAC_STAT_RX_BLOCK_LOCK_REG          0x0000020C /** When set means that the corresponding PCS lane has achieved block lock. */
+#define XCMAC_STAT_RX_LANE_SYNC_REG           0x00000210 /** Indicate whether a PCS lane is word boundary synchronised. A value of 1 indicates that the corresponding PCS lane has achieved word boundary synchronization and it has received a PCS lane marker. */
+#define XCMAC_STAT_RX_LANE_SYNC_ERR_REG       0x00000214 /** When set indicates the corresponding PCS lane lost word boundary synchronization error due to sync header framing bits error or that a PCS lane marked was never received. */
+#define XCMAC_STAT_RX_AM_ERR_REG              0x00000218 /** Count of all invalid or incorrectly formed PCS Lane Marker Words recieved. */
+#define XCMAC_STAT_RX_AM_LEN_ERR_REG          0x0000021C /** Count of PCA lane marker Length Errors indicating the PCS Lane Marker length mismatch. */
+#define XCMAC_STAT_RX_AM_REPEAT_ERR_REG       0x00000220 /** Count of PCS Lane Marker Consecutive errors. */
+#define XCMAC_STAT_RX_LANE_DEMUXED            0x00000224 /** When set means that the receiver has properly de-multiplexed that PCS lane. */
+#define XCMAC_STAT_RX_PCS_LANE_NUM_REG1       0x00000228 /** Indicates which physical lanes are receiving PCS lanes 0-5. */
+#define XCMAC_STAT_RX_PCS_LANE_NUM_REG2       0x0000022C /** Indicates which physical lanes are receiving PCS lanes 6-11. */
+#define XCMAC_STAT_RX_PCS_LANE_NUM_REG3       0x00000230 /** Indicates which physical lanes are receiving PCS lanes 12-17. */
+#define XCMAC_STAT_RX_PCS_LANE_NUM_REG4       0x00000234 /** Indicates which physical lanes are receiving PCS lanes 18-19. */
+#define XCMAC_STAT_RX_BIP_OVERRIDE_REG        0x00000238
+
+//0x023C - 0x02AF        Reserved
+
+//Histogram / Counter Registers macro
+#define XMAC_TICK_REG                0x000002B0
+#define XMAC_STAT_CYCLE_COUNT        0x000002B8
+/* The stat_rx_bip_err signals provide a per-lane indicator of signal quality. A non-zero value indicateis the BIP8 signature byte was in error for the corresponding PCS lane. */
+#define XMAC_STAT_RX_BIP_ERR_0       0x000002C0 /** BIP8 error indicator for PCS lane 0. */
+#define XMAC_STAT_RX_BIP_ERR_1       0x000002C8 /** BIP8 error indicator for PCS lane 1. */
+#define XMAC_STAT_RX_BIP_ERR_2       0x000002D0 /** BIP8 error indicator for PCS lane 2. */
+#define XMAC_STAT_RX_BIP_ERR_3       0x000002D8 /** BIP8 error indicator for PCS lane 3. */
+#define XMAC_STAT_RX_BIP_ERR_4       0x000002E0 /** BIP8 error indicator for PCS lane 4. */
+#define XMAC_STAT_RX_BIP_ERR_5       0x000002E8 /** BIP8 error indicator for PCS lane 5. */
+#define XMAC_STAT_RX_BIP_ERR_6       0x000002F0 /** BIP8 error indicator for PCS lane 6. */
+#define XMAC_STAT_RX_BIP_ERR_7       0x000002F8 /** BIP8 error indicator for PCS lane 7. */
+#define XMAC_STAT_RX_BIP_ERR_8       0x00000300 /** BIP8 error indicator for PCS lane 8. */
+#define XMAC_STAT_RX_BIP_ERR_9       0x00000308 /** BIP8 error indicator for PCS lane 9. */
+#define XMAC_STAT_RX_BIP_ERR_10      0x00000310 /** BIP8 error indicator for PCS lane 10. */
+#define XMAC_STAT_RX_BIP_ERR_11      0x00000318 /** BIP8 error indicator for PCS lane 11. */
+#define XMAC_STAT_RX_BIP_ERR_12      0x00000320 /** BIP8 error indicator for PCS lane 12. */
+#define XMAC_STAT_RX_BIP_ERR_13      0x00000328 /** BIP8 error indicator for PCS lane 13. */
+#define XMAC_STAT_RX_BIP_ERR_14      0x00000330 /** BIP8 error indicator for PCS lane 14. */
+#define XMAC_STAT_RX_BIP_ERR_15      0x00000338 /** BIP8 error indicator for PCS lane 15. */
+#define XMAC_STAT_RX_BIP_ERR_16      0x00000340 /** BIP8 error indicator for PCS lane 16. */
+#define XMAC_STAT_RX_BIP_ERR_17      0x00000348 /** BIP8 error indicator for PCS lane 17. */
+#define XMAC_STAT_RX_BIP_ERR_18      0x00000350 /** BIP8 error indicator for PCS lane 18. */
+#define XMAC_STAT_RX_BIP_ERR_19      0x00000358 /** BIP8 error indicator for PCS lane 19. */
+
+#define XMAC_STAT_RX_FRAMING_ERR_0        0x00000360 /** RX Sync header bits framing error for lane 0. Each PCS lane has a 4-bit bus that indicates the number of sync header errors received for that PCS lane. */
+#define XMAC_STAT_RX_FRAMING_ERR_1        0x00000368 /** RX Sync header bits framing error for lane 1 */
+#define XMAC_STAT_RX_FRAMING_ERR_2        0x00000370 /** RX Sync header bits framing error for lane 2 */
+#define XMAC_STAT_RX_FRAMING_ERR_3        0x00000378 /** RX Sync header bits framing error for lane 3 */
+#define XMAC_STAT_RX_FRAMING_ERR_4        0x00000380 /** RX Sync header bits framing error for lane 4 */
+#define XMAC_STAT_RX_FRAMING_ERR_5        0x00000388 /** RX Sync header bits framing error for lane 5 */
+#define XMAC_STAT_RX_FRAMING_ERR_6        0x00000390 /** RX Sync header bits framing error for lane 6 */
+#define XMAC_STAT_RX_FRAMING_ERR_7        0x00000398 /** RX Sync header bits framing error for lane 7 */
+#define XMAC_STAT_RX_FRAMING_ERR_8        0x000003A0 /** RX Sync header bits framing error for lane 8 */
+#define XMAC_STAT_RX_FRAMING_ERR_9        0x000003A8 /** RX Sync header bits framing error for lane 9 */
+#define XMAC_STAT_RX_FRAMING_ERR_10       0x000003B0 /** RX Sync header bits framing error for lane 10 */
+#define XMAC_STAT_RX_FRAMING_ERR_11       0x000003B8 /** RX Sync header bits framing error for lane 11 */
+#define XMAC_STAT_RX_FRAMING_ERR_12       0x000003C0 /** RX Sync header bits framing error for lane 12 */
+#define XMAC_STAT_RX_FRAMING_ERR_13       0x000003C8 /** RX Sync header bits framing error for lane 13 */
+#define XMAC_STAT_RX_FRAMING_ERR_14       0x000003D0 /** RX Sync header bits framing error for lane 14 */
+#define XMAC_STAT_RX_FRAMING_ERR_15       0x000003D8 /** RX Sync header bits framing error for lane 15 */
+#define XMAC_STAT_RX_FRAMING_ERR_16       0x000003E0 /** RX Sync header bits framing error for lane 16 */
+#define XMAC_STAT_RX_FRAMING_ERR_17       0x000003E8 /** RX Sync header bits framing error for lane 17 */
+#define XMAC_STAT_RX_FRAMING_ERR_18       0x000003F0 /** RX Sync header bits framing error for lane 18 */
+#define XMAC_STAT_RX_FRAMING_ERR_19       0x000003F8 /** RX Sync header bits framing error for lane 19 */
+//0x0400 - 0x0410        Reserved
+
+#define XMAC_STAT_RX_BAD_CODE        0x00000418 /** Counts of 64B/66B code violations */
+//0x0420        Reserved
+//0x0428        Reserved
+//0x0430        Reserved
+//0x0438        Reserved
+//0x0440        Reserved
+//0x0448        Reserved
+//0x0450        Reserved
+
+#define XMAC_STAT_TX_FRAME_ERROR        0x00000458 /** Count of packets with tx_errin set to indicate an EOP abort */
+//0x0460        Reserved
+
+#define XCMAC_STAT_TX_TOTAL_PACKETS               0x00000500 /** Total number of packets transmitted */
+#define XCMAC_STAT_TX_TOTAL_GOOD_PACKETS          0x00000508 /** Total number of good packeets transmitted */
+#define XCMAC_STAT_TX_TOTAL_BYTES                 0x00000510 /** Total number of bytes tranmsitted */
+#define XCMAC_STAT_TX_TOTAL_GOOD_BYTES            0x00000518 /** Total number of good bytes transmitted. This number is only non-zero when a packet is transmitted completely and contains no errors. */
+#define XCMAC_STAT_TX_PACKET_64_BYTES             0x00000520 /** Good or bad packets transmitted containing 64 bytes.*/
+#define XCMAC_STAT_TX_PACKET_65_127_BYTES         0x00000528 /** Good or bad packets transmitted containing 65-127 bytes.*/
+#define XCMAC_STAT_TX_PACKET_128_255_BYTES        0x00000530 /** Good or bad packets transmitted containing 128-255 bytes.*/
+#define XCMAC_STAT_TX_PACKET_256_511_BYTES        0x00000538 /** Good or bad packets transmitted containing 255-511 bytes.*/
+#define XCMAC_STAT_TX_PACKET_512_1023_BYTES       0x00000540 /** Good or bad packets transmitted containing 512-1023 bytes.*/
+#define XCMAC_STAT_TX_PACKET_1024_1518_BYTES      0x00000548 /** Good or bad packets transmitted containing 1024-1518 bytes.*/
+#define XCMAC_STAT_TX_PACKET_1519_1522_BYTES      0x00000550 /** Good or bad packets transmitted containing 1519-1522 bytes.*/
+#define XCMAC_STAT_TX_PACKET_1523_1548_BYTES      0x00000558 /** Good or bad packets transmitted containing 1523-1548 bytes.*/
+#define XCMAC_STAT_TX_PACKET_1549_2047_BYTES      0x00000560 /** Good or bad packets transmitted containing 1549-2047 bytes.*/
+#define XCMAC_STAT_TX_PACKET_2048_4095_BYTES      0x00000568 /** Good or bad packets transmitted containing 2048-4095 bytes.*/
+#define XCMAC_STAT_TX_PACKET_4096_8191_BYTES      0x00000570 /** Good or bad packets transmitted containing 4096-8191 bytes.*/
+#define XCMAC_STAT_TX_PACKET_8192_9215_BYTES      0x00000578 /** Good or bad packets transmitted containing 8192-9215 bytes.*/
+#define XCMAC_STAT_TX_PACKET_LARGE                0x00000580 /** Count of packets that are more than 9215 bytes long */
+#define XCMAC_STAT_TX_PACKET_SMALL                0x00000588 /** Count of packets that ar less than 64 bytes long. Packet transfer of less than 64 bytes is not permitted */
+//0x0590 - 0x05B0       Reserved
+
+#define XCMAC_STAT_TX_BAD_FCS            0x000005B8 /** Packets greater than 64 bytes that have FCS error */
+//0x05C0       Reserved
+//0x05C8       Reserved
+
+#define XCMAC_STAT_TX_UNICAST          0x000005D0 /** Good unicast packets count */
+#define XCMAC_STAT_TX_MULTICAST        0x000005D8 /** Good multicast packets count */
+#define XCMAC_STAT_TX_BROADCAST        0x000005E0 /** Good broadcast packets count */
+#define XCMAC_STAT_TX_VLAN             0x000005E8 /** Good 802.1Q tagged VLAN packets count */
+#define STAT_TX_PAUSE            0x000005F0 /** Count of 802.3x Ethernet MAC Pause packet with good FCS */
+#define STAT_TX_USER_PAUSE       0x000005F8 /** Count of priority based pause packets with good FCS */
+
+//0x0600       Reserved
+#define XCMAC_STAT_RX_TOTAL_PACKETS                0x00000608 /** Total no. of packets received. */
+#define XCMAC_STAT_RX_TOTAL_GOOD_PACKETS           0x00000610 /** Total number of good packets i.e. packets recieved completely and with no errors. */
+#define XCMAC_STAT_RX_TOTAL_BYTES                  0x00000618 /** Total number of bytes received. */
+#define XCMAC_STAT_RX_TOTAL_GOOD_BYTES             0x00000620 /** Total no. of good bytes received i.e. total bytes from good packets. */
+#define XCMAC_STAT_RX_PACKET_64_BYTES              0x00000628 /** Good or bad packets received containing 64 bytes.*/
+#define XCMAC_STAT_RX_PACKET_65_127_BYTES          0x00000630 /** Good or bad packets received containing 65-127 bytes.*/
+#define XCMAC_STAT_RX_PACKET_128_255_BYTES         0x00000638 /** Good or bad packets received containing 128-255 bytes.*/
+#define XCMAC_STAT_RX_PACKET_256_511_BYTES         0x00000640 /** Good or bad packets received containing 256-511 bytes.*/
+#define XCMAC_STAT_RX_PACKET_512_1023_BYTES        0x00000648 /** Good or bad packets received containing 512-1023 bytes.*/
+#define XCMAC_STAT_RX_PACKET_1024_1518_BYTES       0x00000650 /** Good or bad packets received containing 1024-1518 bytes.*/
+#define XCMAC_STAT_RX_PACKET_1519_1522_BYTES       0x00000658 /** Good or bad packets received containing 1519-1522 bytes.*/
+#define XCMAC_STAT_RX_PACKET_1523_1548_BYTES       0x00000660 /** Good or bad packets received containing 1523-1548 bytes.*/
+#define XCMAC_STAT_RX_PACKET_1549_2047_BYTES       0x00000668 /** Good or bad packets received containing 1549-2047 bytes.*/
+#define XCMAC_STAT_RX_PACKET_2048_4095_BYTES       0x00000670 /** Good or bad packets received containing 2048-4095 bytes.*/
+#define XCMAC_STAT_RX_PACKET_4096_8191_BYTES       0x00000678 /** Good or bad packets received containing 4096-8191 bytes.*/
+#define XCMAC_STAT_RX_PACKET_8192_9215_BYTES       0x00000680 /** Good or bad packets received containing 8192-9215 bytes.*/
+#define XCMAC_STAT_RX_PACKET_LARGE                 0x00000688 /** Count of all packets that are more than 9215 bytes long. */
+#define XCMAC_STAT_RX_PACKET_SMALL                 0x00000690 /** Count of all packets that are less than 64 bytes long. */
+#define XCMAC_STAT_RX_UNDERSIZE                    0x00000698 /** Count of all packets shorter than start_rx_min_packet_len with bad FCS. */
+#define XCMAC_STAT_RX_FRAGMENT                     0x000006A0 /** Count of all packets shorter than start_rx_min_packet_len with bad FCS. */
+#define XCMAC_STAT_RX_OVERSIZE                     0x000006A8 /** Count of all packets longer than ctl_rx_max_packet_len with good FCS. */
+#define XCMAC_STAT_RX_TOOLONG                      0x000006B0 /** Count of packets longer than ctl_rx_max_packet_len with good or bad FCS. */
+#define XCMAC_STAT_RX_JABBER                       0x000006B8 /** Count of packets longer than ctl_rx_max_packet_len with bad FCS. */
+#define XCMAC_STAT_RX_BAD_FCS                      0x000006C0 /** Count of packets with bad FCS. */
+#define XCMAC_STAT_RX_PACKET_BAD_FCS               0x000006C8 /** Count of packets between 64 and ctl_rx_max_packet_len_bytes that have FCS errors. */
+#define XCMAC_STAT_RX_STOMPED_FCS                  0x000006D0 /** Count of packet with stomped FCS i.e. bitwise inverse of the expected good FCS. */
+#define XCMAC_STAT_RX_UNICAST                      0x000006D8 /** Count of good unicast packets */
+#define XCMAC_STAT_RX_MULTICAST                    0x000006E0 /** Count of good multicast packets */
+#define XCMAC_STAT_RX_BROADCAST                    0x000006E8 /** Count of good broadcast packets */
+#define XCMAC_STAT_RX_VLAN                         0x000006F0 /** Count of good 802.1Q tagged VLAN packets. */
+#define XCMAC_STAT_RX_PAUSE                        0x000006F8 /** Count of 802.3x Ethernet MAC Pause packets with good FCS */
+#define XCMAC_STAT_RX_USER_PAUSE                   0x00000700 /** Count of priority based pause packets with good FCS */
+#define XCMAC_STAT_RX_INRANGEERR                   0x00000708 /** Count of packets with Length field error but with good FCS */
+#define XCMAC_STAT_RX_TRUNCATED                    0x00000710 /** Count of packets with truncation error due to size of packet exceeding ctl_rx_max_packet_len value. */
+
+/* User defined configurations */
+#define XCMAC_SUCCESS                     0
+#define XCMAC_FAILED                     -1
+#define        XCMAC_NUM_SAMP_DEVS                1
+
+/* statistics refresh period */
+#define XCMAC_STAT_REFRESH_PERIOD       1000
+#define XCMAC_RX_ALIGN_TIME_OUT         0x10
+
+#define XCMAC_RSFEC_CONFIG_INDICATION_CORRECTION 0x1000
+#define XCMAC_RSFEC_CONFIG_ENABLE 0x107C
+
+#define XCMAC_RSFEC_INDI_ENABLE 0x7
+#define XCMAC_RSFEC_ENABLE      0x3
+
 /**
  * enum axienet_ip_type - AXIENET IP/MAC type.
  *
@@ -1089,6 +1376,8 @@ enum axienet_ip_type {
 	XAXIENET_MRMAC,
 	XAXIENET_1G_10G_25G,
 	XAXIENET_DCMAC,
+	XAXIENET_100G,
+	XAXIENET_MRMAC_100G,
 };
 
 struct axienet_config {
diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_dma.c b/drivers/net/ethernet/xilinx/xilinx_axienet_dma.c
old mode 100644
new mode 100755
index 70bd2dfd744c..75e92f5dc360
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_dma.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_dma.c
@@ -391,6 +391,8 @@ void __maybe_unused axienet_dma_err_handler(unsigned long data)
 	struct net_device *ndev = lp->ndev;
 	struct axidma_bd *cur_p;
 
+	if (lp->axienet_config->mactype != XAXIENET_100G &&
+	    lp->axienet_config->mactype != XAXIENET_MRMAC_100G)
 	lp->axienet_config->setoptions(ndev, lp->options &
 				       ~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
 	/* When we do an Axi Ethernet reset, it resets the complete core
@@ -503,9 +505,12 @@ void __maybe_unused axienet_dma_err_handler(unsigned long data)
 	if (lp->axienet_config->mactype != XAXIENET_10G_25G)
 		axienet_iow(lp, XAE_FCC_OFFSET, XAE_FCC_FCRX_MASK);
 
-	lp->axienet_config->setoptions(ndev, lp->options &
+	if (lp->axienet_config->mactype != XAXIENET_100G &&
+	    lp->axienet_config->mactype != XAXIENET_MRMAC_100G) {
+		lp->axienet_config->setoptions(ndev, lp->options &
 			   ~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
-	axienet_set_mac_address(ndev, NULL);
-	axienet_set_multicast_list(ndev);
-	lp->axienet_config->setoptions(ndev, lp->options);
+		axienet_set_mac_address(ndev, NULL);
+		axienet_set_multicast_list(ndev);
+		lp->axienet_config->setoptions(ndev, lp->options);
+	}
 }
diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
old mode 100644
new mode 100755
index 85b5731f9d56..37ef4c6b09de
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@ -96,6 +96,7 @@ EXPORT_SYMBOL(mrmac_pll_reg);
 
 int mrmac_pll_rst;
 EXPORT_SYMBOL(mrmac_pll_rst);
+static void xcmac_100G_reset(struct axienet_local *xcmac_dev);
 
 /* Option table for setting up Axi Ethernet hardware options */
 static struct axienet_option axienet_options[] = {
@@ -476,6 +477,78 @@ static void xxvenet_setoptions(struct net_device *ndev, u32 options)
 	lp->options |= options;
 }
 
+static inline void axienet_mrmac_100g_reset(struct axienet_local *lp)
+{
+	u32 val, reg;
+
+	axienet_iow(lp, MRMAC_RESET_OFFSET, MRMAC_STS_ALL_MASK);
+	mdelay(MRMAC_RESET_DELAY);
+
+	reg = axienet_ior(lp, MRMAC_MODE_OFFSET);
+	reg &= ~MRMAC_CTL_RATE_CFG_MASK;
+	reg |= MRMAC_CTL_DATA_RATE_100G;
+	reg |= (MRMAC_CTL_AXIS_CFG_100G_IND << MRMAC_CTL_AXIS_CFG_SHIFT);
+	reg |= (MRMAC_CTL_SERDES_WIDTH_100G <<
+			MRMAC_CTL_SERDES_WIDTH_SHIFT);
+
+	axienet_iow(lp, MRMAC_FEC_CONFIG_REG1_OFFSET,
+			MRMAC_RSFEC_TX_FOUR_LANE_PMD | MRMAC_RSFEC_OP_MODE);
+
+	/* For tick reg */
+	reg |= MRMAC_CTL_PM_TICK_MASK;
+	axienet_iow(lp, MRMAC_MODE_OFFSET, reg);
+
+	axienet_iow(lp, MRMAC_RESET_OFFSET, 0);
+	/* For Flow Control*/
+	axienet_iow(lp, MRMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG1,
+			MRMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG1_VAL);
+	axienet_iow(lp, MRMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG2,
+			MRMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG2_VAL);
+
+	axienet_iow(lp, MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG1,
+			MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG1_VAL);
+	axienet_iow(lp, MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG2,
+			MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG2_VAL);
+	axienet_iow(lp, MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG3,
+			MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG3_VAL);
+	axienet_iow(lp, MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG4,
+			MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG4_VAL);
+	axienet_iow(lp, MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG5,
+			MRMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG5_VAL);
+	axienet_iow(lp, MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG1,
+			MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG1_VAL);
+	axienet_iow(lp, MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG2,
+			MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG2_VAL);
+	axienet_iow(lp, MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG3,
+			MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG3_VAL);
+	axienet_iow(lp, MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG4,
+			MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG4_VAL);
+	axienet_iow(lp, MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG5,
+			MRMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG5_VAL);
+}
+
+static inline int axienet_mrmac_100g_gt_reset(struct net_device *ndev)
+{
+	struct axienet_local *lp = netdev_priv(ndev);
+	u32 err, val;
+
+	iowrite32(MRMAC_GT_100G_RST_VALUE, lp->gt_ctrl);
+	iowrite32(MRMAC_GT_100G_LINE_RATE, lp->gt_ctrl);
+	if (mrmac_pll_rst == 0) {
+		/* Wait for PLL lock with timeout */
+		err = readl_poll_timeout(lp->gt_pll,
+					 val, (val & MRMAC_GT_LOCK_MASK),
+					 10, DELAY_OF_ONE_MILLISEC);
+		if (err) {
+			netdev_err(ndev, "MRMAC PLL lock not complete! Cross-check the MAC ref clock configuration\n");
+			return -ENODEV;
+		}
+		mrmac_pll_rst = 1;
+		netdev_info(ndev, "MRMAC 100G GT PLL LOCK complete\n");
+	}
+	return 0;
+}
+
 static inline void axienet_mrmac_reset(struct axienet_local *lp)
 {
 	u32 val, reg;
@@ -789,6 +862,86 @@ static inline int xxv_gt_reset(struct net_device *ndev)
 	return 0;
 }
 
+/* CMAC Reset operation */
+static void xcmac_100G_reset(struct axienet_local *xcmac_dev)
+{
+	unsigned long timeout;
+	/* Rx align time out delay */
+	unsigned long rx_align_time_out = XCMAC_RX_ALIGN_TIME_OUT;
+
+	/* Enable Tx Register */
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_TX_REG1_OFFSET, XCMAC_CONFIG_TX_REG1_ENABLE_MASK);
+	mdelay(10);
+
+	/* Enable RX enable and TX send RFI */
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_RX_REG1_OFFSET,
+			XCMAC_CONFIG_RX_REG1_ENABLE_MASK);
+	mdelay(10);
+
+
+	/* Enable RS-FEC */
+	axienet_iow(xcmac_dev, XCMAC_RSFEC_CONFIG_INDICATION_CORRECTION, XCMAC_RSFEC_INDI_ENABLE);
+	mdelay(10);
+	axienet_iow(xcmac_dev, XCMAC_RSFEC_CONFIG_ENABLE, XCMAC_RSFEC_ENABLE );
+	mdelay(500);
+
+	/* Wait until CMAC core RX aligned, by polling the stat_rx_aligned reg
+	 * Note: Here you need to first perform a dummy read and then ignore
+	 * the read value and then keep polling the stat_rx_aligned bit for HIGH.
+	 * This is because the stat registers are all sticky bits and they
+	 * latch the values until they are read.
+	 *  */
+	/* Dummy Read */
+	axienet_ior(xcmac_dev, XCMAC_STAT_RX_STATUS_REG_OFFSET);
+	mdelay(50);
+
+	timeout = jiffies;
+	while (!(axienet_ior(xcmac_dev, XCMAC_STAT_RX_STATUS_REG_OFFSET) &
+				(XCMAC_STAT_RX_STATUS_REG_ALIGNED_MASK | XCMAC_STAT_RX_STATUS_REG_STATUS_MASK))) {
+		axienet_iow(xcmac_dev, XCMAC_GT_RESET_REG_OFFSET,
+				(XCMAC_STAT_RX_STATUS_REG_STATUS_MASK |
+				 XCMAC_STAT_RX_STATUS_REG_ALIGNED_MASK |
+				 XCMAC_STAT_RX_STATUS_REG_MIS_ALIGNED_MASK));
+		mdelay(100);
+		/* Dummy Read */
+		axienet_ior(xcmac_dev, XCMAC_STAT_RX_STATUS_REG_OFFSET);
+		mdelay(50);
+		if (time_after(jiffies, (timeout + rx_align_time_out * HZ))) {
+			pr_err("XCMAC RX alignment timeout!\n");
+			break;
+		}
+	}
+
+	/* For Flow Control*/
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG1,
+			XCMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG1_VAL);
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG2,
+			XCMAC_CONFIG_RX_FLOW_CONTROL_CONTROL_REG2_VAL);
+
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG1,
+			XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG1_VAL);
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG2,
+			XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG2_VAL);
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG3,
+			XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG3_VAL);
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG4,
+			XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG4_VAL);
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG5,
+			XCMAC_CONFIG_TX_FLOW_CONTROL_QUANTA_REG5_VAL);
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG1,
+			XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG1_VAL);
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG2,
+			XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG2_VAL);
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG3,
+			XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG3_VAL);
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG4,
+			XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG4_VAL);
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG5,
+			XCMAC_CONFIG_TX_FLOW_CONTROL_REFRESH_REG5_VAL);
+	axienet_iow(xcmac_dev, XCMAC_CONFIG_TX_FLOW_CONTROL_CONTROL_REG1,
+			XCMAC_CONFIG_TX_FLOW_CONTROL_CONTROL_REG1_VAL);
+}
+
 void __axienet_device_reset(struct axienet_dma_q *q)
 {
 	u32 timeout;
@@ -840,6 +993,20 @@ static int axienet_device_reset(struct net_device *ndev)
 	if (lp->axienet_config->mactype == XAXIENET_MRMAC) {
 		/* Reset MRMAC */
 		axienet_mrmac_reset(lp);
+
+		if (axienet_mrmac_gt_reset(ndev))
+			return;
+	}
+
+
+
+
+	if (lp->axienet_config->mactype == XAXIENET_MRMAC_100G) {
+		/* Reset MRMAC 100G*/
+		axienet_mrmac_100g_reset(lp);
+
+		if (axienet_mrmac_100g_gt_reset(ndev))
+			return;
 	}
 
 	if (lp->axienet_config->gt_reset) {
@@ -878,7 +1045,12 @@ static int axienet_device_reset(struct net_device *ndev)
 		return ret;
 	}
 
+	if (lp->axienet_config->mactype == XAXIENET_100G)
+		xcmac_100G_reset(lp);
 	if (lp->axienet_config->mactype != XAXIENET_10G_25G &&
+	    lp->axienet_config->mactype != XAXIENET_MRMAC &&
+	    lp->axienet_config->mactype != XAXIENET_100G &&
+	    lp->axienet_config->mactype != XAXIENET_MRMAC_100G &&
 	    lp->axienet_config->mactype != XAXIENET_1G_10G_25G &&
 	    lp->axienet_config->mactype != XAXIENET_MRMAC &&
 	    lp->axienet_config->mactype != XAXIENET_DCMAC) {
@@ -955,11 +1127,17 @@ static int axienet_device_reset(struct net_device *ndev)
 		lp->options |= XAE_OPTION_FCS_STRIP;
 		lp->options |= XAE_OPTION_FCS_INSERT;
 	} else {
-		axienet_iow(lp, XAE_FCC_OFFSET, XAE_FCC_FCRX_MASK);
+		if (lp->axienet_config->mactype != XAXIENET_100G &&
+		    lp->axienet_config->mactype != XAXIENET_MRMAC_100G)
+			axienet_iow(lp, XAE_FCC_OFFSET, XAE_FCC_FCRX_MASK);
+	}
+
+	if (lp->axienet_config->setoptions){
+		if (lp->axienet_config->mactype != XAXIENET_100G &&
+	    	lp->axienet_config->mactype != XAXIENET_MRMAC_100G) {
+			lp->axienet_config->setoptions(ndev, lp->options &
+				      	 ~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
 	}
-	if (lp->axienet_config->setoptions)
-		lp->axienet_config->setoptions(ndev, lp->options &
-					~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
 
 	axienet_set_mac_address(ndev, NULL);
 	axienet_set_multicast_list(ndev);
@@ -1518,6 +1696,9 @@ static int axienet_queue_xmit(struct sk_buff *skb,
 	struct axienet_dma_q *q;
 
 	if (lp->axienet_config->mactype == XAXIENET_10G_25G ||
+	    lp->axienet_config->mactype == XAXIENET_MRMAC ||
+	    lp->axienet_config->mactype == XAXIENET_100G ||
+	    lp->axienet_config->mactype == XAXIENET_MRMAC_100G) ||
 	    lp->axienet_config->mactype == XAXIENET_1G_10G_25G ||
 	    lp->axienet_config->mactype == XAXIENET_MRMAC ||
 	    lp->axienet_config->mactype == XAXIENET_DCMAC) {
@@ -1988,6 +2169,41 @@ static irqreturn_t axienet_eth_irq(int irq, void *_ndev)
 	return IRQ_HANDLED;
 }
 
+static irqreturn_t axigpio_irq_handler(int irq, void *ndev)
+{
+	struct axienet_local *lp = netdev_priv(ndev);
+	unsigned int value, rx_val;
+
+	rx_val = ioread32(lp->gpio_regs + GPIO_CHN1_DATA_REG);
+	rx_val &= 0x1;
+	/* BIT0 - 0 means link down; BIT0 - 1 means link up
+	 * Checking the CMAC RX status and doing CMAC Reset
+	 * irrespective of the GPIO value.
+	 */
+	if (1) {
+		/* Dummy read: This is because the stat registers are all
+		 * sticky bits and they latch the values until they are read.
+		 */
+		value = axienet_ior(lp, XCMAC_STAT_RX_STATUS_REG_OFFSET);
+		mdelay(50);
+		value = axienet_ior(lp, XCMAC_STAT_RX_STATUS_REG_OFFSET);
+		if (!(value & (XCMAC_STAT_RX_STATUS_REG_ALIGNED_MASK |
+			XCMAC_STAT_RX_STATUS_REG_STATUS_MASK))) {
+			axienet_iow(lp, XCMAC_GT_RESET_REG_OFFSET,
+				(XCMAC_STAT_RX_STATUS_REG_STATUS_MASK |
+				 XCMAC_STAT_RX_STATUS_REG_ALIGNED_MASK |
+				 XCMAC_STAT_RX_STATUS_REG_MIS_ALIGNED_MASK));
+		}
+		value = axienet_ior(lp, XCMAC_STAT_RX_STATUS_REG_OFFSET);
+		if (rx_val && (value & (XCMAC_STAT_RX_STATUS_REG_ALIGNED_MASK |
+			XCMAC_STAT_RX_STATUS_REG_STATUS_MASK))) {
+			printk("XCMAC is UP now!\n");
+		}
+	}
+	iowrite32(GPIO_INT_CHN1_MASK, lp->gpio_regs + GPIO_INT_STS_REG);
+	return IRQ_HANDLED;
+}
+
 static void
 axienet_config_autoneg_link_training(struct axienet_local *lp, unsigned int speed_config)
 {
@@ -2232,6 +2448,7 @@ static int axienet_open(struct net_device *ndev)
 			ret = -ENODEV;
 			goto err_eth_irq;
 		}
+		netdev_info(ndev, "MRMAC setup at %d\n", lp->mrmac_rate);
 
 		axienet_iow(lp, MRMAC_STATRX_VALID_CTRL_OFFSET, MRMAC_STS_ALL_MASK);
 		val = axienet_ior(lp, MRMAC_STATRX_VALID_CTRL_OFFSET);
@@ -2245,6 +2462,43 @@ static int axienet_open(struct net_device *ndev)
 		axienet_iow(lp, MRMAC_TICK_OFFSET, MRMAC_TICK_TRIGGER);
 	}
 
+	if (lp->axienet_config->mactype == XAXIENET_MRMAC_100G) {
+		u32 val;
+		unsigned long timeout = jiffies;
+
+		/* Reset MRMAC */
+		axienet_mrmac_100g_reset(lp);
+
+		mdelay(MRMAC_RESET_DELAY);
+		/* Check for block lock bit to be set. This ensures that
+		 * MRMAC ethernet IP is functioning normally.
+		 */
+		axienet_iow(lp, MRMAC_TX_STS_OFFSET, MRMAC_STS_ALL_MASK);
+		axienet_iow(lp, MRMAC_RX_STS_OFFSET, MRMAC_STS_ALL_MASK);
+		axienet_iow(lp, MRMAC_STATRX_BLKLCK_OFFSET, MRMAC_STS_ALL_MASK);
+
+		while (!((val = axienet_ior(lp, MRMAC_RX_STS_OFFSET)) &
+					MRMAC_RX_ALIGN_MASK)) {
+			axienet_iow(lp, MRMAC_RX_STS_OFFSET, MRMAC_STS_ALL_MASK);
+			mdelay(100);
+			if (time_after(jiffies, (timeout + XCMAC_RX_ALIGN_TIME_OUT * HZ))) {
+				pr_err("MRMAC 100G RX alignment timeout!\n");
+				break;
+			}
+		}
+
+		while (!((val = axienet_ior(lp, MRMAC_STATRX_BLKLCK_OFFSET)) &
+					MRMAC_RX_100G_BLKLCK_MASK)) {
+			axienet_iow(lp, MRMAC_STATRX_BLKLCK_OFFSET, MRMAC_STS_ALL_MASK);
+			mdelay(100);
+			if (time_after(jiffies, (timeout + XCMAC_RX_ALIGN_TIME_OUT * HZ))) {
+				pr_err("MRMAC 100G RX block lock timeout!\n");
+				break;
+			}
+		}
+		axienet_iow(lp, MRMAC_TICK_OFFSET, MRMAC_TICK_TRIGGER);
+	}
+
 	/* Enable interrupts for Axi Ethernet core (if defined) */
 	if (!lp->eth_hasnobuf && lp->axienet_config->mactype == XAXIENET_1_2p5G) {
 		ret = request_irq(lp->eth_irq, axienet_eth_irq, IRQF_SHARED,
@@ -2253,6 +2507,16 @@ static int axienet_open(struct net_device *ndev)
 			goto err_eth_irq;
 	}
 
+	if ((lp->axienet_config->mactype == XAXIENET_100G) && lp->gpio_irq) {
+		ret = request_irq(lp->gpio_irq, axigpio_irq_handler,
+				IRQF_SHARED, AXI_GPIO_INT, ndev);
+		if (ret) {
+			netdev_err(ndev, "ERROR gpio request_irq %d\n", ret);
+			lp->gpio_irq = 0;
+			goto err_eth_irq;
+		}
+
+
 	/* If Runtime speed switching supported */
 	if (lp->axienet_config->mactype == XAXIENET_10G_25G &&
 	    (axienet_ior(lp, XXV_STAT_CORE_SPEED_OFFSET) &
@@ -2310,11 +2574,14 @@ static int axienet_stop(struct net_device *ndev)
 
 	dev_dbg(&ndev->dev, "axienet_close()\n");
 
-	if (lp->phylink) {
-		phylink_stop(lp->phylink);
-		phylink_disconnect_phy(lp->phylink);
-	}
+	if (lp->axienet_config->mactype != XAXIENET_100G &&
+	    lp->axienet_config->mactype != XAXIENET_MRMAC_100G){
 
+		if (lp->phylink) {
+			phylink_stop(lp->phylink);
+			phylink_disconnect_phy(lp->phylink);
+		}
+	}
 	if (lp->axienet_config->setoptions)
 		lp->axienet_config->setoptions(ndev, lp->options &
 				~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
@@ -2328,6 +2595,9 @@ static int axienet_stop(struct net_device *ndev)
 		cr = axienet_dma_in32(q, XAXIDMA_TX_CR_OFFSET);
 		cr &= ~(XAXIDMA_CR_RUNSTOP_MASK | XAXIDMA_IRQ_ALL_MASK);
 		axienet_dma_out32(q, XAXIDMA_TX_CR_OFFSET, cr);
+		if (lp->axienet_config->mactype != XAXIENET_MRMAC_100G)
+			axienet_iow(lp, XAE_IE_OFFSET, 0);
+
 		if (lp->axienet_config->mactype == XAXIENET_1_2p5G)
 			axienet_iow(lp, XAE_IE_OFFSET, 0);
 
@@ -2362,6 +2632,9 @@ static int axienet_stop(struct net_device *ndev)
 	if (lp->axienet_config->mactype == XAXIENET_1_2p5G && !lp->eth_hasnobuf)
 		free_irq(lp->eth_irq, ndev);
 
+	if ((lp->axienet_config->mactype == XAXIENET_100G)
+			&lp->gpio_irq)
+		free_irq(lp->gpio_irq, ndev);
 	axienet_dma_bd_release(ndev);
 
 	/* Delete the GRO Filter Rules when Reset is done */
@@ -2394,14 +2667,22 @@ static int axienet_change_mtu(struct net_device *ndev, int new_mtu)
 {
 	struct axienet_local *lp = netdev_priv(ndev);
 
-	if (netif_running(ndev))
-		return -EBUSY;
+	if (lp->axienet_config->mactype == XAXIENET_100G ||
+	    lp->axienet_config->mactype == XAXIENET_MRMAC_100G) {
+		if (netif_running(ndev))
+			axienet_stop(ndev);
+		ndev->mtu = new_mtu;
+		axienet_open(ndev);
+	} else {
+		if (netif_running(ndev))
+			return -EBUSY;
 
-	if ((new_mtu + VLAN_ETH_HLEN +
-		XAE_TRL_SIZE) > lp->rxmem)
-		return -EINVAL;
+		if ((new_mtu + VLAN_ETH_HLEN +
+			XAE_TRL_SIZE) > lp->rxmem)
+			return -EINVAL;
 
-	ndev->mtu = new_mtu;
+		ndev->mtu = new_mtu;
+	}
 
 	return 0;
 }
@@ -3242,6 +3523,36 @@ static int __maybe_unused axienet_dma_probe(struct platform_device *pdev,
 	return 0;
 }
 
+static void axienet_100G_link_sts(struct platform_device *pdev,
+		struct net_device *ndev)
+{
+	struct axienet_local *lp = netdev_priv(ndev);
+	struct device_node *np = NULL;
+	struct resource gpiores;
+	int ret;
+
+	np = of_parse_phandle(pdev->dev.of_node, "axigpio-handle", 0);
+	if (np) {
+		ret = of_address_to_resource(np, 0, &gpiores);
+		if (ret >= 0) {
+			lp->gpio_regs = devm_ioremap_resource(&pdev->dev,
+					&gpiores);
+			if (IS_ERR(lp->regs)) {
+				dev_err(&pdev->dev, "unable to ioremap GPIO resource\n");
+				return;
+			}
+		} else {
+			dev_err(&pdev->dev, "unable to get GPIO resource\n");
+			return;
+		}
+		lp->gpio_irq = irq_of_parse_and_map(np, 0);
+	} else {
+		dev_err(&pdev->dev, "missing axigpio-handle property\n");
+		return;
+	}
+	return;
+}
+
 static struct axienet_local *pcs_to_axienet_local(struct phylink_pcs *pcs)
 {
 	return container_of(pcs, struct axienet_local, pcs);
@@ -3891,6 +4202,13 @@ static const struct axienet_config axienet_mrmac_config = {
 	.gt_reset = axienet_mrmac_gt_reset,
 };
 
+static const struct axienet_config cmac_100g_config = {
+	.mactype = XAXIENET_100G,
+	.setoptions = NULL,
+	.clk_init = xxvenet_clk_init,
+	.tx_ptplen = 0,
+};
+
 static const struct axienet_config axienet_dcmac_config = {
 	.mactype = XAXIENET_DCMAC,
 	.clk_init = xxvenet_clk_init,
@@ -3907,10 +4225,19 @@ static const struct of_device_id axienet_of_match[] = {
 	{ .compatible = "xlnx,ten-gig-eth-mac", .data = &axienet_10g_config},
 	{ .compatible = "xlnx,xxv-ethernet-1.0",
 						.data = &axienet_10g25g_config},
+	{ .compatible = "xlnx,tsn-ethernet-1.00.a", .data = &axienet_1g_config},
 	{ .compatible = "xlnx,xxv-usxgmii-ethernet-1.0",
 					.data = &axienet_usxgmii_config},
 	{ .compatible = "xlnx,mrmac-ethernet-1.0",
 					.data = &axienet_mrmac_config},
+	{ .compatible = "xlnx,mrmac-100g-ethernet-1.0",
+					.data = &mrmac_100g_config},
+	{ .compatible = "xlnx,cmac-usplus-2.4",
+					.data = &cmac_100g_config},
+	{ .compatible = "xlnx,cmac-usplus-3.0",
+					.data = &cmac_100g_config},
+	{ .compatible = "xlnx,cmac-usplus-3.1",
+					.data = &cmac_100g_config},
 	{ .compatible = "xlnx,ethernet-1-10-25g-2.7",
 					.data = &axienet_1g10g25g_config},
 	{ .compatible = "xlnx,dcmac-2.4",
@@ -4200,7 +4527,8 @@ static int axienet_probe(struct platform_device *pdev)
 	    !lp->eth_hasnobuf)
 		lp->eth_irq = platform_get_irq(pdev, 0);
 
-	if (lp->axienet_config->mactype == XAXIENET_MRMAC) {
+	if (lp->axienet_config->mactype == XAXIENET_MRMAC ||
+	    lp->axienet_config->mactype == XAXIENET_MRMAC_100G) {
 		struct resource gtpll, gtctrl;
 
 		if (mrmac_pll_reg) {
@@ -4627,6 +4955,9 @@ static int axienet_probe(struct platform_device *pdev)
 	 * network configuration parameters.
 	 */
 
+	if (lp->axienet_config->mactype == XAXIENET_100G)
+		axienet_100G_link_sts(pdev, ndev);
+
 	if (lp->eoe_features & RX_HW_UDP_GRO) {
 		lp->inetaddr_notifier.notifier_call = axienet_eoe_netdev_event;
 		ret = register_inetaddr_notifier(&lp->inetaddr_notifier);
diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_mcdma.c b/drivers/net/ethernet/xilinx/xilinx_axienet_mcdma.c
old mode 100644
new mode 100755
index 9ae994bc369a..f0bfe2c45e5d
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_mcdma.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_mcdma.c
@@ -616,8 +616,11 @@ void __maybe_unused axienet_mcdma_err_handler(unsigned long data)
 	struct net_device *ndev = lp->ndev;
 	struct aximcdma_bd *cur_p;
 
-	lp->axienet_config->setoptions(ndev, lp->options &
-				       ~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
+	if (lp->axienet_config->mactype != XAXIENET_100G &&
+	    lp->axienet_config->mactype != XAXIENET_MRMAC_100G)
+			lp->axienet_config->setoptions(ndev, lp->options &
+				       		~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
+
 	/* When we do an Axi Ethernet reset, it resets the complete core
 	 * including the MDIO. MDIO must be disabled before resetting.
 	 * Hold MDIO bus lock to avoid MDIO accesses during the reset.
@@ -762,12 +765,15 @@ void __maybe_unused axienet_mcdma_err_handler(unsigned long data)
 	}
 #endif
 
-	lp->axienet_config->setoptions(ndev, lp->options &
-				       ~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
-	axienet_set_mac_address(ndev, NULL);
-	axienet_set_multicast_list(ndev);
-	lp->axienet_config->setoptions(ndev, lp->options);
-}
+	if (lp->axienet_config->mactype != XAXIENET_100G &&
+	    lp->axienet_config->mactype != XAXIENET_MRMAC_100G) {
+			lp->axienet_config->setoptions(ndev, lp->options &
+				     	  ~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
+			axienet_set_mac_address(ndev, NULL);
+			axienet_set_multicast_list(ndev);
+			lp->axienet_config->setoptions(ndev, lp->options);
+		}
+	}
 
 int __maybe_unused axienet_mcdma_tx_probe(struct platform_device *pdev,
 					  struct device_node *np,
